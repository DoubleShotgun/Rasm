require("string")
require("arg")
if #arg==0 then
	print("rasm usage: "..arg[0].." [d]o a.out filein.asm")
	return 2
end

require("C.stdio")
require("io") 
require("os")
require("hashmap")
require("sequence")
require("math")

require("common")
require("argHandling")
require("label")
require("instr")
require("base")
require("multiply")
require("pseudo")
require("elf")

local curLabel:string
local addressLabel:int64  
local preAddressLabel:int64

local file = io.open(filein)
if not file:isopen() then
	print("Error: unable to open filein")
	os.exit(1)
end

local cfile

if execArgs.dump then
	cfile = C.fopen("dump.bin","wb+")
end

local function parseString(str:string)
	local escape=false
	local retStr = ""
	
	for _,char in ipairs(str) do
		if escape then
			switch char do
			case 34 then -- "
				retStr = retStr.."\""
			case 39 then -- '
				retStr = retStr.."\'"
			case 92 then -- \
				retStr = retStr.."\\"
			case 97 then -- a
				retStr = retStr.."\a"
			case 98 then -- b
				retStr = retStr.."\b"
			case 101 then -- e
				retStr = retStr..string.char(0x1b)
			case 110 then -- n
				retStr = retStr.."\n"
			case 114 then -- n
				retStr = retStr.."\r"
			case 116 then -- t
				retStr = retStr.."\t"
			else
				print("Error: Invaild escape sequence")
				os.exit(1)
			end
			escape=false
		else
			switch char do
			case 92 then -- \
				escape=true
			case 39 then -- '
				fallthrough
			case 34 then -- "
				return retStr
			else
				retStr = retStr..string.char(char)
			end
		end
			
	end
	return retStr
end

for line in file:lines() do
	if line:match("#") then continue end
	if line:match("%s*%S*:%s*$") then
	
		local label:string = select(2,line:match("%s*(%S*):"))[1]
		if curLabel~="" then
			labels[curLabel] = {preAddressLabel,addressLabel-preAddressLabel}
		end
		preAddressLabel = addressLabel
		curLabel=label
	elseif line:match("%S+%s*=%s*%S+") then
		if line:match("[\"']") then
			local args = select(2,line:match("(%S+)%s*=%s*\"(.*)\""))
			local str = parseString(args[2])

			for i=1,#str do
				program[#program+1] = (@uint8)(str[i])
			end
			
			local len = #str
			if #str%2==1 then
				len = len+1
			end
			
			stringLen = stringLen+#str
			labels[args[1]] = {addressLabel,len}
			addressLabel=addressLabel+#str
			
			if #str%2==1 then
				program[#program+1]=0
				addressLabel=addressLabel+1
			end
		else
			local args = select(2,line:match("%s*(%S*)%s*=%s*(.*)"))
			labels[args[1]] = {(@uint64)(tointeger(args[2])),-1}
		end
	elseif line:match("%S") then
	
		local _,b = line:match("%s*([^%s]*)%s*(.*)")
		local mnemonic = b[1]:lower()
		local length
		if instruction:has(mnemonic) then
			length = 4
		else
			local size,args = getArgs(mnemonic,b[2])
			length = #pseudoInstr[mnemonic].assemble(args)
		end
		addressLabel=addressLabel+length
	end 
end

labels[curLabel] = {preAddressLabel,addressLabel-preAddressLabel}


if not labels:has("_start") then
	print("Error: failed to find '_start' label")
	os.exit(1)
end

global curLine = 1
file:seek("set")

local function addInstrToProgram(instr:[4]uint8)
	for i=0,3 do
		program[#program+1] = instr[i]
	end
end


for line in file:lines() do
	if line:match("^%s*#") then continue end
	
	if line:match("%S") then
		local _,b = line:match("%s*([^%s]*)%s*(.*)")
		local mnemonic = b[1]:lower()
		local size,args = getArgs(mnemonic,b[2])
		
		if instruction:has(mnemonic) then
			addInstrToProgram(getInstr(mnemonic,args))
		elseif pseudoInstr:has(mnemonic) then
			local bytes = pseudoInstr[mnemonic].assemble(args)
			for i=1,#bytes do
				program[#program+1] = bytes[i]
			end
		end
	end
	
	curLine = curLine+1
end

file:close()

if execArgs.dump then
	for _,v in ipairs(program) do
		C.fwrite(&v,1,1,cfile)
	end
	C.fclose(cfile)
end

writeToFile(fileout,program,labels["_start"].value,false)
io.popen("chmod +x "..fileout)
