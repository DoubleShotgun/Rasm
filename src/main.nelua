require("string")
require("arg")
if #arg==0 then
	print("rasm usage: "..arg[0].." [d]o a.out filein.asm")
	return 2
end

require("C.stdio")
require("io") 
require("os")
require("hashmap")
require("sequence")
require("math")


global program:sequence(uint32)
global stringLen:uint64

global function getProgramSize() <inline>
	return #program*4
end

require("argHandling")
require("label")
require("instr")
require("base")
require("multiply")
require("pseudo")
require("elf")

local curLabel:string
local addressLabel:int64  
local preAddressLabel:int64

local file = io.open(filein)
if not file then
	print("Error: unable to open filein")
	os.exit(1)
end

local cfile

if execArgs.dump then
	cfile = C.fopen("dump.bin","wb+")
end

local function parseString(str:string)
	local escape=false
	local retStr = ""
	
	str = str:sub(2,#str)
	for _,char in ipairs(str) do
		if escape then
			switch char do
			case 34 then -- "
				retStr = retStr.."\""
			case 39 then -- '
				retStr = retStr.."\'"
			case 92 then -- \
				retStr = retStr.."\\"
			case 97 then -- a
				retStr = retStr.."\a"
			case 98 then -- b
				retStr = retStr.."\b"
			case 101 then -- e
				retStr = retStr..0x1b
			case 110 then -- n
				retStr = retStr.."\n"
			case 114 then -- n
				retStr = retStr.."\r"
			case 116 then -- t
				retStr = retStr.."\t"
			else
				print("Error: Invaild escape sequence")
				os.exit(1)
			end
			escape=false
		else
			switch char do
			case 92 then -- \
				escape=true
			case 39 then -- '
				fallthrough
			case 34 then -- "
				return retStr
			else
				retStr = retStr..string.char(char)
			end
		end
			
	end
	return retStr
end


for line in file:lines() do
	if line:match("^%s*#") then continue end
	if line:match("%s*%S*:%s*$") then
	
		local label:string = select(2,line:match("%s*(%S*):"))[1]
		if curLabel~="" then
			labels[curLabel] = {preAddressLabel,addressLabel-preAddressLabel}
		end
		preAddressLabel = addressLabel
		curLabel=label
	elseif line:match("%S+%s*=%s*%S+") then
		local args = select(2,line:match("(%S+)%s*=%s*(%S+)"))
		if args[2]:match("[\"']") then
			local str = parseString(args[2])
			--Rounds up the length of the string to the nearest dividable by 4
			local len = (#str + 3) & ~0b11
			local pi
			for i=0,<#str do
				if i%4==0 then
					pi = #program+1
				end
				program[pi] = program[pi] | (@uint32)(str[i+1])<<((i%4))*8
			end
			stringLen = stringLen+len
			
			labels[args[1]] = {addressLabel,len}
			addressLabel=addressLabel+len
		else
			labels[args[1]] = {(@uint64)(tointeger(args[2])),-1}
		end
	elseif line:match("%S") then
	
		local _,b = line:match("%s*([^%s]*)%s*(.*)")
		local mnemonic = b[1]:lower()
		local length
		if instruction:has(mnemonic) then
			length = 4
		else
			local size,args = getArgs(mnemonic,b[2])
			length = #pseudoInstr[mnemonic].assemble(args)*4
		end
		addressLabel=addressLabel+length
	end 
end
labels[curLabel] = {preAddressLabel,addressLabel-preAddressLabel}

if not labels:has("_start") then
	print("Error: failed to find '_start' label")
	os.exit(1)
end

global curLine = 1
file:seek("set")


for line in file:lines() do
	if line:match("^%s*#") then continue end
	
	if line:match("%S") then
		local _,b = line:match("%s*([^%s]*)%s*(.*)")
		local mnemonic = b[1]:lower()
		local size,args = getArgs(mnemonic,b[2])
		
		if instruction:has(mnemonic) then
			program[#program+1] = getInstr(mnemonic,args)
		elseif pseudoInstr:has(mnemonic) then
			local instres = pseudoInstr[mnemonic].assemble(args)
			for i=1,#instres do
				program[#program+1] = instres[i]
			end
		end
	end
	
	curLine = curLine+1
end

file:close()

if execArgs.dump then
	for _,v in ipairs(program) do
		C.fwrite(&v,4,1,cfile)
	end
	C.fclose(cfile)
end

writeToFile(fileout,program,labels["_start"].value,true)
io.popen("chmod +x "..fileout)