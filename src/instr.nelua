global instrType = @enum{
	n = 0, -- Only for ecall and ebreak
	i,
	r,
	s, 
	sb,
	u,
	uj
}

global instruction:hashmap(string,@record{
	type:instrType,
	opcode:uint8,
	func3:uint8,
	func7:uint8,
})

global function getArgs(mnemonic:string,argsStr:string):(isize,[3]uint32)
	
	local size:isize 
	local args:[3]uint32
	if instruction:has(mnemonic) then
		switch instruction[mnemonic].type do
		case instrType.n then
			size = 0
		case instrType.u then
			fallthrough
		case instrType.uj then
			size = 2
		case instrType.s then
			fallthrough
		case instrType.sb then
			fallthrough
		case instrType.r then
			fallthrough
		case instrType.i then
			size = 3
		end
	end
	
	local _,a = argsStr:match("%s*([-%%_%w%d]*)[,%s]*([-%%_%w%d]*)[,%s]*([-%%_%w%d]*)")
	
	for i=0,<3 do
		local str = a[i+1]
		if str=="" then break end
		if str:match("^-?%d*$") then
			args[i] = (@uint32)(tointeger(str))
		elseif labels:has(str) then
			if labels[str].length==-1 then
				args[i] = labels[str].value
			else
				args[i] = (@uint32)(labels[str].value-getProgramSize())
			end
		elseif str:match("^%%") then
			local label = str:sub(2,#str)
			if labels:has(label) then
				args[i] = (@uint32)(labels[label].length)
			end
		end
	end
	return size,args
end

global function getInstr(mnemonic:string,args:[3]uint32):uint32
	if not instruction:has(mnemonic) then
		print("Error: no such mnemonic")
		os.exit(1)
	end
	
	local curInstr = instruction[mnemonic]
	local instr:uint32 = curInstr.opcode
	switch curInstr.type do
	case instrType.n then
		instr = instr | ((@uint32)(curInstr.func7)<<20)
	case instrType.r then
		fallthrough
	case instrType.i then
		instr = instr | (args[0]<<7)
		instr = instr | (args[1]<<15)
		instr = instr | (args[2]<<20)
		instr = instr | ((@uint32)(curInstr.func3)<<12)
		instr = instr | ((@uint32)(curInstr.func7)<<25)
	case instrType.s then
		instr = instr | (args[0]<<15)
		instr = instr | (args[1]<<20)
		instr = instr | ((args[2]&0x1f)<<7)
	  instr = instr | ((args[2]>>5)<<25)
		instr = instr | ((@uint32)(curInstr.func3)<<12)
	case instrType.sb then
		instr = instr | (args[0]<<15)
		instr = instr | (args[1]<<20)
		instr = instr | ((args[2]&0x001e)<<7)
	  instr = instr | ((args[2]&0x07e0)<<20)
		instr = instr | ((args[2]&0x0800)>>4)
		instr = instr | ((args[2]&0x1000)<<19)
		instr = instr | ((@uint32)(curInstr.func3)<<12)
	case instrType.u then
		instr = instr | (args[0]<<7)
		instr = instr | (args[1]<<12)
	case instrType.uj then
		instr = instr | (args[0]<<7)
		instr = instr | ((args[1]&0b11111111110)<<20) -- 10:1
		instr = instr | (((args[1]>>11)&1)<<20) -- 11
		instr = instr | (((args[1]>>12)&0b011111111)<<12) -- 19:12
		instr = instr | (((args[1]>>20))<<31) -- 20
	end
	return instr
end