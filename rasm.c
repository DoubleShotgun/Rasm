/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "../rasm.c" -x none -fwrapv -fno-strict-aliasing -g -lm -o "../rasm" */
/* Compile hash: 2oMCHwpzNsD8QhGmtyinxNjMxQJB */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #pragma clang diagnostic ignored "-Wmissing-braces"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
    #pragma clang diagnostic ignored "-Wc99-designator"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
/* Macro used to perform compile-time checks. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_STATIC_ASSERT _Static_assert
#elif __cplusplus >= 201103L
  #define NELUA_STATIC_ASSERT static_assert
#else
  #define NELUA_STATIC_ASSERT(x, y)
#endif
/* Macro used to get alignment of a type. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_ALIGNOF _Alignof
#elif __cplusplus >= 201103L
  #define NELUA_ALIGNOF alignof
#elif defined(__GNUC__)
  #define NELUA_ALIGNOF __alignof__
#elif defined(_MSC_VER)
  #define NELUA_ALIGNOF __alignof
#else
  #define NELUA_ALIGNOF(x)
#endif
/* Checks if Nelua and C agrees on pointer size. */
NELUA_STATIC_ASSERT(sizeof(void*) == 8 && NELUA_ALIGNOF(void*) == 8, "Nelua and C disagree on pointer size or alignment");
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#include <string.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
#include <stddef.h>
#define NELUA_NIL (nlniltype){}
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
/* Macro used suppress sanitizer errors when the GC is scanning. */
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
#include <errno.h>
/* Include basic POSIX constants and APIs */
#if !defined(_WIN32) && (defined(__unix__) || defined(__unix) || \
                        (defined(__APPLE__) && defined(__MACH__)) || \
                        defined(__HAIKU__))
  #include <unistd.h>
#endif
/* Macro used to silence fallthrough warnings. */
#if defined(__GNUC__) && __GNUC__ >= 7
  #define NELUA_FALLTHROUGH() __attribute__((fallthrough))
#else
  #define NELUA_FALLTHROUGH() ((void)0)
#endif
/* Macro used to take reference of literals. */
#define NELUA_LITERAL_REF(T, x) (&((struct{T v;}){x}.v))
/* ------------------------------ DECLARATIONS ------------------------------ */
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nlstring) == 16 && NELUA_ALIGNOF(nlstring) == 8, "Nelua and C disagree on type size or align");
static void nelua_assert_line_1(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static void nelua_assert_line_2(bool cond, nlstring msg);
static NELUA_INLINE int32_t nelua_memory_compare(void* a, void* b, uintptr_t n);
static void nelua_assert_line_3(bool cond, nlstring msg);
static NELUA_INLINE bool nelua_memory_equals(void* a, void* b, uintptr_t n);
static void nelua_assert_line_4(bool cond, nlstring msg);
static void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize);
static void nelua_assert_line_5(bool cond, nlstring msg);
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE void* nelua_assert_deref(void* p);
typedef uint8_t* nluint8_ptr;
typedef struct nelua_span_uint8_ nelua_span_uint8_;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_uint8_) == 16 && NELUA_ALIGNOF(nelua_span_uint8_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8_ self);
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i);
static void nelua_assert_line_6(bool cond, nlstring msg);
typedef void** nlpointer_ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pointer_) == 16 && NELUA_ALIGNOF(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i);
static void nelua_assert_line_7(bool cond, nlstring msg);
typedef struct nelua_GCScanRange nelua_GCScanRange;
typedef nelua_GCScanRange* nelua_GCScanRange_ptr;
struct nelua_GCScanRange {
  uintptr_t low;
  uintptr_t high;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCScanRange) == 16 && NELUA_ALIGNOF(nelua_GCScanRange) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_GCScanRange_ nelua_span_GCScanRange_;
typedef nelua_GCScanRange* nelua_GCScanRange_arr0_ptr;
struct nelua_span_GCScanRange_ {
  nelua_GCScanRange_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_GCScanRange_) == 16 && NELUA_ALIGNOF(nelua_span_GCScanRange_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_GCScanRange_ptr nelua_span_GCScanRange____atindex(nelua_span_GCScanRange_ self, uintptr_t i);
static void nelua_assert_line_8(bool cond, nlstring msg);
typedef uintptr_t* nlusize_ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_usize_) == 16 && NELUA_ALIGNOF(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i);
static void nelua_assert_line_9(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef struct nelua_GCItem nelua_GCItem;
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCItem) == 32 && NELUA_ALIGNOF(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__GCItem_) == 56 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i);
static void nelua_assert_line_10(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_pointer__usize_ nelua_hashmapnode_pointer__usize_;
typedef nelua_hashmapnode_pointer__usize_* nelua_hashmapnode_pointer__usize__ptr;
struct nelua_hashmapnode_pointer__usize_ {
  void* key;
  uintptr_t value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__usize_) == 32 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__usize__ nelua_span_hashmapnode_pointer__usize__;
typedef nelua_hashmapnode_pointer__usize_* nelua_hashmapnode_pointer__usize__arr0_ptr;
struct nelua_span_hashmapnode_pointer__usize__ {
  nelua_hashmapnode_pointer__usize__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__usize__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__usize__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_pointer__usize__ptr nelua_span_hashmapnode_pointer__usize_____atindex(nelua_span_hashmapnode_pointer__usize__ self, uintptr_t i);
static void nelua_assert_line_11(bool cond, nlstring msg);
typedef nlstring* nlstring_ptr;
typedef struct nelua_span_string_ nelua_span_string_;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_string_) == 16 && NELUA_ALIGNOF(nelua_span_string_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i);
static void nelua_assert_line_12(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_uint8__V_ nelua_hashmapnode_uint8__V_;
typedef nelua_hashmapnode_uint8__V_* nelua_hashmapnode_uint8__V__ptr;
typedef struct nelua_V_2 nelua_V_2;
typedef int64_t argHandling_optType;
struct nelua_V_2 {
  argHandling_optType type;
  void* execArgsP;
};
NELUA_STATIC_ASSERT(sizeof(nelua_V_2) == 16 && NELUA_ALIGNOF(nelua_V_2) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_uint8__V_ {
  uint8_t key;
  nelua_V_2 value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_uint8__V_) == 40 && NELUA_ALIGNOF(nelua_hashmapnode_uint8__V_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_uint8__V__ nelua_span_hashmapnode_uint8__V__;
typedef nelua_hashmapnode_uint8__V_* nelua_hashmapnode_uint8__V__arr0_ptr;
struct nelua_span_hashmapnode_uint8__V__ {
  nelua_hashmapnode_uint8__V__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_uint8__V__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_uint8__V__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_uint8__V__ptr nelua_span_hashmapnode_uint8__V_____atindex(nelua_span_hashmapnode_uint8__V__ self, uintptr_t i);
static void nelua_assert_line_13(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_string__V_ nelua_hashmapnode_string__V_;
typedef nelua_hashmapnode_string__V_* nelua_hashmapnode_string__V__ptr;
typedef struct nelua_V_3 nelua_V_3;
struct nelua_V_3 {
  uint64_t value;
  int64_t length;
};
NELUA_STATIC_ASSERT(sizeof(nelua_V_3) == 16 && NELUA_ALIGNOF(nelua_V_3) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_string__V_ {
  nlstring key;
  nelua_V_3 value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_string__V_) == 48 && NELUA_ALIGNOF(nelua_hashmapnode_string__V_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_string__V__ nelua_span_hashmapnode_string__V__;
typedef nelua_hashmapnode_string__V_* nelua_hashmapnode_string__V__arr0_ptr;
struct nelua_span_hashmapnode_string__V__ {
  nelua_hashmapnode_string__V__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_string__V__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_string__V__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_string__V__ptr nelua_span_hashmapnode_string__V_____atindex(nelua_span_hashmapnode_string__V__ self, uintptr_t i);
static void nelua_assert_line_14(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_string__V__1 nelua_hashmapnode_string__V__1;
typedef nelua_hashmapnode_string__V__1* nelua_hashmapnode_string__V__1_ptr;
typedef struct nelua_V_4 nelua_V_4;
typedef int64_t instr_instrType;
struct nelua_V_4 {
  instr_instrType type;
  uint8_t opcode;
  uint8_t func3;
  uint8_t func7;
};
NELUA_STATIC_ASSERT(sizeof(nelua_V_4) == 16 && NELUA_ALIGNOF(nelua_V_4) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_string__V__1 {
  nlstring key;
  nelua_V_4 value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_string__V__1) == 48 && NELUA_ALIGNOF(nelua_hashmapnode_string__V__1) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_string__V___1 nelua_span_hashmapnode_string__V___1;
typedef nelua_hashmapnode_string__V__1* nelua_hashmapnode_string__V__1_arr0_ptr;
struct nelua_span_hashmapnode_string__V___1 {
  nelua_hashmapnode_string__V__1_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_string__V___1) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_string__V___1) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_string__V__1_ptr nelua_span_hashmapnode_string__V___1___atindex(nelua_span_hashmapnode_string__V___1 self, uintptr_t i);
static void nelua_assert_line_15(bool cond, nlstring msg);
typedef uint64_t* nluint64_ptr;
typedef struct nelua_span_uint64_ nelua_span_uint64_;
typedef uint64_t* nluint64_arr0_ptr;
struct nelua_span_uint64_ {
  nluint64_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_uint64_) == 16 && NELUA_ALIGNOF(nelua_span_uint64_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nluint64_ptr nelua_span_uint64____atindex(nelua_span_uint64_ self, uintptr_t i);
static void nelua_assert_line_16(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_string__V__2 nelua_hashmapnode_string__V__2;
typedef nelua_hashmapnode_string__V__2* nelua_hashmapnode_string__V__2_ptr;
typedef struct nelua_V_5 nelua_V_5;
typedef struct nelua_sequence_uint8_ nelua_sequence_uint8_;
typedef struct nelua_sequenceimpl_uint8_ nelua_sequenceimpl_uint8_;
typedef nelua_sequenceimpl_uint8_* nelua_sequenceimpl_uint8__ptr;
typedef struct nelua_GCAllocator nelua_GCAllocator;
struct nelua_GCAllocator {};
struct nelua_sequence_uint8_ {
  nelua_sequenceimpl_uint8__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_uint8_) == 8 && NELUA_ALIGNOF(nelua_sequence_uint8_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_sequence_uint64_ nelua_sequence_uint64_;
typedef struct nelua_sequenceimpl_uint64_ nelua_sequenceimpl_uint64_;
typedef nelua_sequenceimpl_uint64_* nelua_sequenceimpl_uint64__ptr;
struct nelua_sequence_uint64_ {
  nelua_sequenceimpl_uint64__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_uint64_) == 8 && NELUA_ALIGNOF(nelua_sequence_uint64_) == 8, "Nelua and C disagree on type size or align");
typedef nelua_sequence_uint8_ (*function_dZWinLkmVZrbymrX)(nelua_sequence_uint64_);
struct nelua_V_5 {
  uint8_t argc;
  function_dZWinLkmVZrbymrX assemble;
};
NELUA_STATIC_ASSERT(sizeof(nelua_V_5) == 16 && NELUA_ALIGNOF(nelua_V_5) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_string__V__2 {
  nlstring key;
  nelua_V_5 value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_string__V__2) == 48 && NELUA_ALIGNOF(nelua_hashmapnode_string__V__2) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_uint64_ {
  nelua_span_uint64_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_uint64_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_uint64_) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_uint8_ {
  nelua_span_uint8_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_uint8_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_uint8_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_string__V___2 nelua_span_hashmapnode_string__V___2;
typedef nelua_hashmapnode_string__V__2* nelua_hashmapnode_string__V__2_arr0_ptr;
struct nelua_span_hashmapnode_string__V___2 {
  nelua_hashmapnode_string__V__2_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_string__V___2) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_string__V___2) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_string__V__2_ptr nelua_span_hashmapnode_string__V___2___atindex(nelua_span_hashmapnode_string__V___2 self, uintptr_t i);
static void nelua_assert_line_17(bool cond, nlstring msg);
typedef struct elf_elf64Shdr elf_elf64Shdr;
typedef elf_elf64Shdr* elf_elf64Shdr_ptr;
struct elf_elf64Shdr {
  uint32_t sh_name;
  uint32_t sh_type;
  uint64_t sh_flags;
  uint64_t sh_addr;
  uint64_t sh_offset;
  uint64_t sh_size;
  uint32_t sh_link;
  uint32_t sh_info;
  uint64_t sh_addralign;
  uint64_t sh_entsize;
};
NELUA_STATIC_ASSERT(sizeof(elf_elf64Shdr) == 64 && NELUA_ALIGNOF(elf_elf64Shdr) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_elf64Shdr_ nelua_span_elf64Shdr_;
typedef elf_elf64Shdr* elf_elf64Shdr_arr0_ptr;
struct nelua_span_elf64Shdr_ {
  elf_elf64Shdr_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_elf64Shdr_) == 16 && NELUA_ALIGNOF(nelua_span_elf64Shdr_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE elf_elf64Shdr_ptr nelua_span_elf64Shdr____atindex(nelua_span_elf64Shdr_ self, uintptr_t i);
static void nelua_assert_line_18(bool cond, nlstring msg);
typedef struct elf_elf64Sym elf_elf64Sym;
typedef elf_elf64Sym* elf_elf64Sym_ptr;
struct elf_elf64Sym {
  uint32_t st_name;
  uint8_t st_info;
  uint8_t st_other;
  uint16_t st_shndx;
  uint64_t st_value;
  uint64_t st_size;
};
NELUA_STATIC_ASSERT(sizeof(elf_elf64Sym) == 24 && NELUA_ALIGNOF(elf_elf64Sym) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_elf64Sym_ nelua_span_elf64Sym_;
typedef elf_elf64Sym* elf_elf64Sym_arr0_ptr;
struct nelua_span_elf64Sym_ {
  elf_elf64Sym_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_elf64Sym_) == 16 && NELUA_ALIGNOF(nelua_span_elf64Sym_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE elf_elf64Sym_ptr nelua_span_elf64Sym____atindex(nelua_span_elf64Sym_ self, uintptr_t i);
static void nelua_assert_line_19(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_string__uint32_ nelua_hashmapnode_string__uint32_;
typedef nelua_hashmapnode_string__uint32_* nelua_hashmapnode_string__uint32__ptr;
struct nelua_hashmapnode_string__uint32_ {
  nlstring key;
  uint32_t value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_string__uint32_) == 32 && NELUA_ALIGNOF(nelua_hashmapnode_string__uint32_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_string__uint32__ nelua_span_hashmapnode_string__uint32__;
typedef nelua_hashmapnode_string__uint32_* nelua_hashmapnode_string__uint32__arr0_ptr;
struct nelua_span_hashmapnode_string__uint32__ {
  nelua_hashmapnode_string__uint32__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_string__uint32__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_string__uint32__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_string__uint32__ptr nelua_span_hashmapnode_string__uint32_____atindex(nelua_span_hashmapnode_string__uint32__ self, uintptr_t i);
static void nelua_assert_line_20(bool cond, nlstring msg);
typedef struct nlmulret_nlboolean_nlint64_nluint8 {
  bool r1;
  int64_t r2;
  uint8_t r3;
} nlmulret_nlboolean_nlint64_nluint8;
typedef nlmulret_nlboolean_nlint64_nluint8 (*function_3LPNAr7nduHuY3ETf)(nlstring_ptr, int64_t);
typedef struct nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64 {
  function_3LPNAr7nduHuY3ETf r1;
  nlstring_ptr r2;
  int64_t r3;
} nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64;
static NELUA_INLINE nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64 nelua_ipairs_1(nlstring_ptr a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next(nlstring_ptr a_1, int64_t k);
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x);
typedef struct nlmulret_nlboolean_nlint64_nlstring {
  bool r1;
  int64_t r2;
  nlstring r3;
} nlmulret_nlboolean_nlint64_nlstring;
typedef struct nelua_sequence_string__1 nelua_sequence_string__1;
typedef struct nelua_sequenceimpl_string__1 nelua_sequenceimpl_string__1;
typedef nelua_sequenceimpl_string__1* nelua_sequenceimpl_string__1_ptr;
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_sequence_string__1 {
  nelua_sequenceimpl_string__1_ptr impl;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_string__1) == 8 && NELUA_ALIGNOF(nelua_sequence_string__1) == 8, "Nelua and C disagree on type size or align");
typedef nlmulret_nlboolean_nlint64_nlstring (*function_eUm9hA9ggP1BUyYv)(nelua_sequence_string__1, int64_t);
struct nelua_sequenceimpl_string__1 {
  nelua_span_string_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_string__1) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_string__1) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64 {
  function_eUm9hA9ggP1BUyYv r1;
  nelua_sequence_string__1 r2;
  int64_t r3;
} nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64;
static NELUA_INLINE nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64 nelua_ipairs_2(nelua_sequence_string__1 a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next_1(nelua_sequence_string__1 a_2, int64_t k);
typedef struct nlmulret_nlboolean_nlint64_nluint64 {
  bool r1;
  int64_t r2;
  uint64_t r3;
} nlmulret_nlboolean_nlint64_nluint64;
typedef nlmulret_nlboolean_nlint64_nluint64 (*function_4JwRVx4oQFacTf3dV)(nelua_sequence_uint64_, int64_t);
typedef struct nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 {
  function_4JwRVx4oQFacTf3dV r1;
  nelua_sequence_uint64_ r2;
  int64_t r3;
} nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64;
static NELUA_INLINE nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 nelua_ipairs_3(nelua_sequence_uint64_ a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_nluint64 nelua_ipairs_next_2(nelua_sequence_uint64_ a_3, int64_t k);
typedef nlmulret_nlboolean_nlint64_nluint8 (*function_2jz3PiVxWVVz2SR8n)(nelua_sequence_uint8_, int64_t);
typedef struct nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64 {
  function_2jz3PiVxWVVz2SR8n r1;
  nelua_sequence_uint8_ r2;
  int64_t r3;
} nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64;
static NELUA_INLINE nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64 nelua_ipairs_4(nelua_sequence_uint8_ a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next_3(nelua_sequence_uint8_ a_4, int64_t k);
typedef struct nlmulret_nlboolean_nlpointer_nlusize {
  bool r1;
  void* r2;
  uintptr_t r3;
} nlmulret_nlboolean_nlpointer_nlusize;
typedef struct nelua_hashmap_iteratorT_1 nelua_hashmap_iteratorT_1;
typedef nelua_hashmap_iteratorT_1* nelua_hashmap_iteratorT_1_ptr;
typedef nlmulret_nlboolean_nlpointer_nlusize (*function_2mALLZkSFbNDkE6o4)(nelua_hashmap_iteratorT_1_ptr, void*);
typedef struct nelua_hashmap_pointer__usize_ nelua_hashmap_pointer__usize_;
typedef nelua_hashmap_pointer__usize_* nelua_hashmap_pointer__usize__ptr;
struct nelua_hashmap_iteratorT_1 {
  nelua_hashmap_pointer__usize__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT_1) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT_1) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_pointer__usize_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__usize__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__usize_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer {
  function_2mALLZkSFbNDkE6o4 r1;
  nelua_hashmap_iteratorT_1 r2;
  void* r3;
} nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer;
static NELUA_INLINE nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer nelua_pairs_1(nelua_hashmap_pointer__usize__ptr a);
typedef struct nlmulret_nlboolean_nlstring_nluint32 {
  bool r1;
  nlstring r2;
  uint32_t r3;
} nlmulret_nlboolean_nlstring_nluint32;
typedef struct nelua_hashmap_iteratorT_6 nelua_hashmap_iteratorT_6;
typedef nelua_hashmap_iteratorT_6* nelua_hashmap_iteratorT_6_ptr;
typedef nlmulret_nlboolean_nlstring_nluint32 (*function_Be9dheYyhVZZMPGH)(nelua_hashmap_iteratorT_6_ptr, nlstring);
typedef struct nelua_hashmap_string__uint32_ nelua_hashmap_string__uint32_;
typedef nelua_hashmap_string__uint32_* nelua_hashmap_string__uint32__ptr;
struct nelua_hashmap_iteratorT_6 {
  nelua_hashmap_string__uint32__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT_6) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT_6) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_string__uint32_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__uint32__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_string__uint32_) == 48 && NELUA_ALIGNOF(nelua_hashmap_string__uint32_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring {
  function_Be9dheYyhVZZMPGH r1;
  nelua_hashmap_iteratorT_6 r2;
  nlstring r3;
} nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring;
static NELUA_INLINE nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring nelua_pairs_2(nelua_hashmap_string__uint32__ptr a);
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_4vXvvEhXfi6WJuzfV)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer {
  function_4vXvvEhXfi6WJuzfV r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer;
static NELUA_INLINE nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
typedef struct nelua_sequence_string_ nelua_sequence_string_;
typedef nelua_sequence_string_* nelua_sequence_string__ptr;
typedef struct nelua_sequenceimpl_string_ nelua_sequenceimpl_string_;
typedef nelua_sequenceimpl_string_* nelua_sequenceimpl_string__ptr;
struct nelua_sequence_string_ {
  nelua_sequenceimpl_string__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_string_) == 8 && NELUA_ALIGNOF(nelua_sequence_string_) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_string_ {
  nelua_span_string_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_string_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_string_) == 8, "Nelua and C disagree on type size or align");
static void nelua_sequence_string___init(nelua_sequence_string__ptr self);
static void nelua_sequence_string__reserve(nelua_sequence_string__ptr self, uintptr_t n);
static void nelua_sequence_string__resize(nelua_sequence_string__ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow(nelua_sequence_string__ptr self);
static void nelua_assert_line_21(bool cond, nlstring msg);
static NELUA_INLINE nlstring_ptr nelua_sequence_string____atindex(nelua_sequence_string__ptr self, uintptr_t pos);
static void nelua_assert_line_22(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_string____len(nelua_sequence_string__ptr self);
typedef nelua_sequence_string__1* nelua_sequence_string__1_ptr;
static void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self);
static void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self);
static void nelua_assert_line_23(bool cond, nlstring msg);
static NELUA_INLINE nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos);
static void nelua_assert_line_24(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self);
typedef nelua_sequence_uint8_* nelua_sequence_uint8__ptr;
static void nelua_sequence_uint8___init(nelua_sequence_uint8__ptr self);
static void nelua_sequence_uint8__reserve(nelua_sequence_uint8__ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_2(nelua_sequence_uint8__ptr self);
static void nelua_assert_line_25(bool cond, nlstring msg);
static NELUA_INLINE nluint8_ptr nelua_sequence_uint8____atindex(nelua_sequence_uint8__ptr self, uintptr_t pos);
static void nelua_assert_line_26(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_uint8____len(nelua_sequence_uint8__ptr self);
typedef struct NELUA_MAYALIAS nluint8_arr4 {uint8_t v[4];} nluint8_arr4;
typedef union NELUA_MAYALIAS nluint8_arr4_cast {nluint8_arr4 a; uint8_t p[4];} nluint8_arr4_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr4) == 4 && NELUA_ALIGNOF(nluint8_arr4) == 1, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_sequence_uint8_ nelua_sequence_uint8____convert_1(nluint8_arr4 values);
static NELUA_INLINE uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len);
typedef nelua_sequence_uint64_* nelua_sequence_uint64__ptr;
static void nelua_sequence_uint64___init(nelua_sequence_uint64__ptr self);
static void nelua_sequence_uint64__reserve(nelua_sequence_uint64__ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_3(nelua_sequence_uint64__ptr self);
static void nelua_assert_line_27(bool cond, nlstring msg);
static NELUA_INLINE nluint64_ptr nelua_sequence_uint64____atindex(nelua_sequence_uint64__ptr self, uintptr_t pos);
static void nelua_assert_line_28(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_uint64____len(nelua_sequence_uint64__ptr self);
typedef struct NELUA_MAYALIAS nluint64_arr3 {uint64_t v[3];} nluint64_arr3;
typedef union NELUA_MAYALIAS nluint64_arr3_cast {nluint64_arr3 a; uint64_t p[3];} nluint64_arr3_cast;
NELUA_STATIC_ASSERT(sizeof(nluint64_arr3) == 24 && NELUA_ALIGNOF(nluint64_arr3) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_sequence_uint64_ nelua_sequence_uint64____convert_1(nluint64_arr3 values);
typedef struct NELUA_MAYALIAS nluint64_arr2 {uint64_t v[2];} nluint64_arr2;
typedef union NELUA_MAYALIAS nluint64_arr2_cast {nluint64_arr2 a; uint64_t p[2];} nluint64_arr2_cast;
NELUA_STATIC_ASSERT(sizeof(nluint64_arr2) == 16 && NELUA_ALIGNOF(nluint64_arr2) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_sequence_uint64_ nelua_sequence_uint64____convert_2(nluint64_arr2 values);
typedef struct nelua_sequence_elf64Shdr_ nelua_sequence_elf64Shdr_;
typedef nelua_sequence_elf64Shdr_* nelua_sequence_elf64Shdr__ptr;
typedef struct nelua_sequenceimpl_elf64Shdr_ nelua_sequenceimpl_elf64Shdr_;
typedef nelua_sequenceimpl_elf64Shdr_* nelua_sequenceimpl_elf64Shdr__ptr;
struct nelua_sequence_elf64Shdr_ {
  nelua_sequenceimpl_elf64Shdr__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_elf64Shdr_) == 8 && NELUA_ALIGNOF(nelua_sequence_elf64Shdr_) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_elf64Shdr_ {
  nelua_span_elf64Shdr_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_elf64Shdr_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_elf64Shdr_) == 8, "Nelua and C disagree on type size or align");
static void nelua_sequence_elf64Shdr___init(nelua_sequence_elf64Shdr__ptr self);
static NELUA_NOINLINE void nelua_sequenceT_grow_4(nelua_sequence_elf64Shdr__ptr self);
static void nelua_assert_line_29(bool cond, nlstring msg);
static NELUA_INLINE elf_elf64Shdr_ptr nelua_sequence_elf64Shdr____atindex(nelua_sequence_elf64Shdr__ptr self, uintptr_t pos);
static void nelua_assert_line_30(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_elf64Shdr____len(nelua_sequence_elf64Shdr__ptr self);
typedef struct nelua_sequence_elf64Sym_ nelua_sequence_elf64Sym_;
typedef nelua_sequence_elf64Sym_* nelua_sequence_elf64Sym__ptr;
typedef struct nelua_sequenceimpl_elf64Sym_ nelua_sequenceimpl_elf64Sym_;
typedef nelua_sequenceimpl_elf64Sym_* nelua_sequenceimpl_elf64Sym__ptr;
struct nelua_sequence_elf64Sym_ {
  nelua_sequenceimpl_elf64Sym__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_elf64Sym_) == 8 && NELUA_ALIGNOF(nelua_sequence_elf64Sym_) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_elf64Sym_ {
  nelua_span_elf64Sym_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_elf64Sym_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_elf64Sym_) == 8, "Nelua and C disagree on type size or align");
static void nelua_sequence_elf64Sym___init(nelua_sequence_elf64Sym__ptr self);
static NELUA_NOINLINE void nelua_sequenceT_grow_5(nelua_sequence_elf64Sym__ptr self);
static void nelua_assert_line_31(bool cond, nlstring msg);
static NELUA_INLINE elf_elf64Sym_ptr nelua_sequence_elf64Sym____atindex(nelua_sequence_elf64Sym__ptr self, uintptr_t pos);
static void nelua_assert_line_32(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_elf64Sym____len(nelua_sequence_elf64Sym__ptr self);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_string_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static void nelua_GeneralAllocator_spandealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_xspanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size);
static nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static NELUA_INLINE uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step);
static NELUA_INLINE uintptr_t nelua_hash_long(nelua_span_uint8_ data);
static uintptr_t nelua_hash_hash_1(void* v);
static uintptr_t nelua_hash_hash_2(uint8_t v);
static uintptr_t nelua_hash_hash_3(nlstring v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_33(bool cond);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static void nelua_assert_line_34(bool cond, nlstring msg);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static bool nelua_hashmap_pointer__GCItem__erase(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
static void nelua_hashmap_pointer__usize__destroy(nelua_hashmap_pointer__usize__ptr self);
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__usize___find(nelua_hashmap_pointer__usize__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__usize__rehash(nelua_hashmap_pointer__usize__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_35(bool cond);
static uintptr_t nelua_hashmap_pointer__usize___at(nelua_hashmap_pointer__usize__ptr self, void* key);
static void nelua_assert_line_36(bool cond, nlstring msg);
static nlusize_ptr nelua_hashmap_pointer__usize____atindex(nelua_hashmap_pointer__usize__ptr self, void* key);
static uintptr_t nelua_hashmap_pointer__usize__remove(nelua_hashmap_pointer__usize__ptr self, void* key);
static NELUA_INLINE nelua_hashmapnode_pointer__usize__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, void* key);
static NELUA_INLINE nlmulret_nlboolean_nlpointer_nlusize nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, void* key);
static NELUA_INLINE nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer nelua_hashmap_pointer__usize____pairs(nelua_hashmap_pointer__usize__ptr self);
typedef struct nelua_hashmap_uint8__V_ nelua_hashmap_uint8__V_;
typedef nelua_hashmap_uint8__V_* nelua_hashmap_uint8__V__ptr;
struct nelua_hashmap_uint8__V_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_uint8__V__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_uint8__V_) == 48 && NELUA_ALIGNOF(nelua_hashmap_uint8__V_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_uint8__V___find(nelua_hashmap_uint8__V__ptr self, uint8_t key);
static NELUA_NOINLINE void nelua_hashmap_uint8__V__rehash(nelua_hashmap_uint8__V__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_37(bool cond);
static uintptr_t nelua_hashmap_uint8__V___at(nelua_hashmap_uint8__V__ptr self, uint8_t key);
static void nelua_assert_line_38(bool cond, nlstring msg);
typedef nelua_V_2* nelua_V_2_ptr;
static nelua_V_2_ptr nelua_hashmap_uint8__V____atindex(nelua_hashmap_uint8__V__ptr self, uint8_t key);
static nelua_V_2_ptr nelua_hashmap_uint8__V__peek(nelua_hashmap_uint8__V__ptr self, uint8_t key);
static bool nelua_hashmap_uint8__V__has(nelua_hashmap_uint8__V__ptr self, uint8_t key);
typedef struct nelua_hashmap_string__V_ nelua_hashmap_string__V_;
typedef nelua_hashmap_string__V_* nelua_hashmap_string__V__ptr;
struct nelua_hashmap_string__V_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__V__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_string__V_) == 48 && NELUA_ALIGNOF(nelua_hashmap_string__V_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V___find(nelua_hashmap_string__V__ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__V__rehash(nelua_hashmap_string__V__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_39(bool cond);
static uintptr_t nelua_hashmap_string__V___at(nelua_hashmap_string__V__ptr self, nlstring key);
static void nelua_assert_line_40(bool cond, nlstring msg);
typedef nelua_V_3* nelua_V_3_ptr;
static nelua_V_3_ptr nelua_hashmap_string__V____atindex(nelua_hashmap_string__V__ptr self, nlstring key);
static nelua_V_3_ptr nelua_hashmap_string__V__peek(nelua_hashmap_string__V__ptr self, nlstring key);
static bool nelua_hashmap_string__V__has(nelua_hashmap_string__V__ptr self, nlstring key);
typedef struct nelua_hashmap_string__V__1 nelua_hashmap_string__V__1;
typedef nelua_hashmap_string__V__1* nelua_hashmap_string__V__1_ptr;
struct nelua_hashmap_string__V__1 {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__V___1 nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_string__V__1) == 48 && NELUA_ALIGNOF(nelua_hashmap_string__V__1) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V__1__find(nelua_hashmap_string__V__1_ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__V__1_rehash(nelua_hashmap_string__V__1_ptr self, uintptr_t bucket_count);
static void nelua_assert_line_41(bool cond);
static uintptr_t nelua_hashmap_string__V__1__at(nelua_hashmap_string__V__1_ptr self, nlstring key);
static void nelua_assert_line_42(bool cond, nlstring msg);
typedef nelua_V_4* nelua_V_4_ptr;
static nelua_V_4_ptr nelua_hashmap_string__V__1___atindex(nelua_hashmap_string__V__1_ptr self, nlstring key);
static nelua_V_4_ptr nelua_hashmap_string__V__1_peek(nelua_hashmap_string__V__1_ptr self, nlstring key);
static bool nelua_hashmap_string__V__1_has(nelua_hashmap_string__V__1_ptr self, nlstring key);
typedef struct nelua_hashmap_string__V__2 nelua_hashmap_string__V__2;
typedef nelua_hashmap_string__V__2* nelua_hashmap_string__V__2_ptr;
struct nelua_hashmap_string__V__2 {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__V___2 nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_string__V__2) == 48 && NELUA_ALIGNOF(nelua_hashmap_string__V__2) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V__2__find(nelua_hashmap_string__V__2_ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__V__2_rehash(nelua_hashmap_string__V__2_ptr self, uintptr_t bucket_count);
static void nelua_assert_line_43(bool cond);
static uintptr_t nelua_hashmap_string__V__2__at(nelua_hashmap_string__V__2_ptr self, nlstring key);
static void nelua_assert_line_44(bool cond, nlstring msg);
typedef nelua_V_5* nelua_V_5_ptr;
static nelua_V_5_ptr nelua_hashmap_string__V__2___atindex(nelua_hashmap_string__V__2_ptr self, nlstring key);
static nelua_V_5_ptr nelua_hashmap_string__V__2_peek(nelua_hashmap_string__V__2_ptr self, nlstring key);
static bool nelua_hashmap_string__V__2_has(nelua_hashmap_string__V__2_ptr self, nlstring key);
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__uint32___find(nelua_hashmap_string__uint32__ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__uint32__rehash(nelua_hashmap_string__uint32__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_45(bool cond);
static uintptr_t nelua_hashmap_string__uint32___at(nelua_hashmap_string__uint32__ptr self, nlstring key);
static void nelua_assert_line_46(bool cond, nlstring msg);
typedef uint32_t* nluint32_ptr;
static nluint32_ptr nelua_hashmap_string__uint32____atindex(nelua_hashmap_string__uint32__ptr self, nlstring key);
static nluint32_ptr nelua_hashmap_string__uint32__peek(nelua_hashmap_string__uint32__ptr self, nlstring key);
static bool nelua_hashmap_string__uint32__has(nelua_hashmap_string__uint32__ptr self, nlstring key);
static NELUA_INLINE nelua_hashmapnode_string__uint32__ptr nelua_hashmap_iteratorT_6__next_node(nelua_hashmap_iteratorT_6_ptr self, nlstring key);
static NELUA_INLINE nlmulret_nlboolean_nlstring_nluint32 nelua_hashmap_iteratorT_6_next(nelua_hashmap_iteratorT_6_ptr self, nlstring key);
static NELUA_INLINE nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring nelua_hashmap_string__uint32____pairs(nelua_hashmap_string__uint32__ptr self);
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pointer_) == 24 && NELUA_ALIGNOF(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_assert_line_47(bool cond, nlstring msg);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static NELUA_INLINE nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos);
static void nelua_assert_line_48(bool cond, nlstring msg);
typedef struct nelua_vector_GCScanRange_ nelua_vector_GCScanRange_;
typedef nelua_vector_GCScanRange_* nelua_vector_GCScanRange__ptr;
struct nelua_vector_GCScanRange_ {
  nelua_span_GCScanRange_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_GCScanRange_) == 24 && NELUA_ALIGNOF(nelua_vector_GCScanRange_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_GCScanRange__destroy(nelua_vector_GCScanRange__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow_1(nelua_vector_GCScanRange__ptr self);
static void nelua_assert_line_49(bool cond, nlstring msg);
static void nelua_vector_GCScanRange__push(nelua_vector_GCScanRange__ptr self, nelua_GCScanRange v);
static nelua_GCScanRange nelua_vector_GCScanRange__pop(nelua_vector_GCScanRange__ptr self);
static void nelua_assert_line_50(bool cond, nlstring msg);
static NELUA_INLINE bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static NELUA_INLINE uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t addrormask;
  uintptr_t addrandmask;
  uintptr_t stacktop;
  uintptr_t stackbottom;
  nelua_vector_pointer_ finalizeitems;
  nelua_vector_GCScanRange_ scanranges;
  nelua_hashmap_pointer__GCItem_ items;
  nelua_hashmap_pointer__usize_ rootitems;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GC) == 208 && NELUA_ALIGNOF(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize);
static void nelua_assert_line_51(bool cond, nlstring msg);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_scanrange(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static NELUA_NOINLINE void nelua_GC_scanptr(nelua_GC_ptr self, void* ptr);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_scanstack(nelua_GC_ptr self);
typedef union nelua_RegsBuf nelua_RegsBuf;
union nelua_RegsBuf {
  jmp_buf regs;
  void* firstreg;
};
static NELUA_NOINLINE void nelua_GC_mark(nelua_GC_ptr self);
typedef void (*function_2jfxAcq6U1dnkseqH)(nelua_GC_ptr);
static NELUA_NOINLINE void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_assert_line_52(bool cond, nlstring msg);
static void nelua_assert_line_53(bool cond, nlstring msg);
static void nelua_assert_line_54(bool cond, nlstring msg);
static NELUA_NOINLINE void nelua_GC_rehash(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_collect(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_2JB2mT5p6U8prYAPj)(void*, void*);
static bool nelua_GC_step(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2JB2mT5p6U8prYAPj finalizer, void* userdata);
static void nelua_assert_line_55(bool cond, nlstring msg);
static void nelua_assert_line_56(bool cond, nlstring msg);
static void nelua_assert_line_57(bool cond, nlstring msg);
static void nelua_assert_line_58(bool cond, nlstring msg);
static void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize);
static void nelua_assert_line_59(bool cond, nlstring msg);
static void nelua_assert_line_60(bool cond, nlstring msg);
static void nelua_assert_line_61(bool cond, nlstring msg);
static void nelua_GC_restart(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_init(nelua_GC_ptr self, void* stack);
static NELUA_NOINLINE void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_3p2TXK13e3jRvktoU)(int, nlcstring_ptr);
static nelua_GCAllocator nelua_gc_allocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr);
static NELUA_NOINLINE void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_string_ nelua_GCAllocator_spanalloc_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint64_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_elf64Shdr_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_elf64Sym_ nelua_GCAllocator_spanalloc_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_usize_ nelua_GCAllocator_spanalloc_7(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_spanalloc0_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_string__V__ nelua_GCAllocator_spanalloc0_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_spanalloc0_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_spanalloc0_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_spanalloc0_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static NELUA_NOINLINE nelua_sequenceimpl_string__ptr nelua_GCAllocator_new_1(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_62(bool cond, nlstring msg);
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
typedef FILE* FILE_ptr;
typedef int (*function_5EHewGogcy7PehX8r)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_5EHewGogcy7PehX8r closef;
};
NELUA_STATIC_ASSERT(sizeof(nelua_FStream) == 16 && NELUA_ALIGNOF(nelua_FStream) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size, nlniltype flags);
static void nelua_assert_line_63(bool cond, nlstring msg);
static NELUA_NOINLINE nelua_sequenceimpl_uint8__ptr nelua_GCAllocator_new_3(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_64(bool cond, nlstring msg);
static NELUA_NOINLINE nelua_sequenceimpl_uint64__ptr nelua_GCAllocator_new_4(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_65(bool cond, nlstring msg);
static NELUA_NOINLINE nelua_sequenceimpl_elf64Shdr__ptr nelua_GCAllocator_new_5(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_66(bool cond, nlstring msg);
static NELUA_NOINLINE nelua_sequenceimpl_elf64Sym__ptr nelua_GCAllocator_new_6(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_67(bool cond, nlstring msg);
static void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags);
static void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_string_ nelua_GCAllocator_spanrealloc_2(nelua_GCAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_usize_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_uint64_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_uint64_ s, uintptr_t size);
static nelua_span_elf64Shdr_ nelua_GCAllocator_spanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_elf64Shdr_ s, uintptr_t size);
static nelua_span_elf64Sym_ nelua_GCAllocator_spanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_elf64Sym_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_string_ nelua_GCAllocator_xspanrealloc_2(nelua_GCAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_usize_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_uint64_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_uint64_ s, uintptr_t size);
static nelua_span_elf64Shdr_ nelua_GCAllocator_xspanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_elf64Shdr_ s, uintptr_t size);
static nelua_span_elf64Sym_ nelua_GCAllocator_xspanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_elf64Sym_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_spanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_uint8__V__ s, uintptr_t size);
static nelua_span_hashmapnode_string__V__ nelua_GCAllocator_spanrealloc0_3(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V__ s, uintptr_t size);
static nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_spanrealloc0_4(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___1 s, uintptr_t size);
static nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_spanrealloc0_5(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___2 s, uintptr_t size);
static nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_spanrealloc0_6(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint32__ s, uintptr_t size);
static nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_xspanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_uint8__V__ s, uintptr_t size);
static nelua_span_hashmapnode_string__V__ nelua_GCAllocator_xspanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V__ s, uintptr_t size);
static nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_xspanrealloc0_3(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___1 s, uintptr_t size);
static nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_xspanrealloc0_4(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___2 s, uintptr_t size);
static nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_xspanrealloc0_5(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint32__ s, uintptr_t size);
static NELUA_INLINE bool nelua_strchar_1_isalpha(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_islower(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isupper(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isxdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_iscntrl(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isgraph(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isspace(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isalnum(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_ispunct(uint8_t c);
static NELUA_INLINE uint8_t nelua_strchar_1_getbasedigit(uint8_t c);
typedef struct nlmulret_nlboolean_nlint64 {
  bool r1;
  int64_t r2;
} nlmulret_nlboolean_nlint64;
static nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr48) == 48 && NELUA_ALIGNOF(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr48* nluint8_arr48_ptr;
static nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_stringbuilderT) == 24 && NELUA_ALIGNOF(nelua_stringbuilderT) == 8, "Nelua and C disagree on type size or align");
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_assert_line_68(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_assert_line_69(bool cond, nlstring msg);
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i);
static void nelua_assert_line_70(bool cond, nlstring msg);
static nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j);
static nlstring nelua_nlstring_subview_1(nlstring s, intptr_t i, intptr_t j);
static nlstring nelua_nlstring_char_1(int64_t __arg1);
static NELUA_INLINE uint8_t nelua_assert_narrow_nlint64_nluint8(int64_t x);
static nlstring nelua_nlstring_char_2(uint8_t __arg1);
static NELUA_INLINE nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i);
static void nelua_assert_line_71(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_nlstring___len(nlstring a);
static nlstring nelua_nlstring___concat_1(nlstring a, nlstring b);
static nlstring nelua_nlstring___concat_3(int64_t a, nlstring b);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
typedef struct nelua_StrPattCapture nelua_StrPattCapture;
typedef nelua_StrPattCapture* nelua_StrPattCapture_ptr;
struct nelua_StrPattCapture {
  intptr_t init;
  intptr_t len;
};
NELUA_STATIC_ASSERT(sizeof(nelua_StrPattCapture) == 16 && NELUA_ALIGNOF(nelua_StrPattCapture) == 8, "Nelua and C disagree on type size or align");
static bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self);
static bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self);
static bool nelua_match_has_pattern_specials(nlstring pattern);
static bool nelua_match_has_pattern_anchor(nlstring pattern);
typedef struct nelua_StrPatt_1 nelua_StrPatt_1;
struct nelua_StrPatt_1 {
  nlstring source;
  nlstring pattern;
  intptr_t depth;
  intptr_t numcaptures;
  nelua_StrPattCapture capture[32];
  bool plain;
  bool anchor;
};
NELUA_STATIC_ASSERT(sizeof(nelua_StrPatt_1) == 568 && NELUA_ALIGNOF(nelua_StrPatt_1) == 8, "Nelua and C disagree on type size or align");
static nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain);
typedef nelua_StrPatt_1* nelua_StrPatt_1_ptr;
static void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self);
static NELUA_INLINE intptr_t nelua_assert_bounds_nlisize(intptr_t index, uintptr_t len);
typedef struct nlmulret_nlboolean_nlstring_nelua_StrPattCapture {
  bool r1;
  nlstring r2;
  nelua_StrPattCapture r3;
} nlmulret_nlboolean_nlstring_nelua_StrPattCapture;
static nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i);
static intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p);
static bool nelua_match_class(uint8_t c, uint8_t cl);
static intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1);
static void nelua_assert_line_72(bool cond, nlstring msg);
static void nelua_assert_line_73(bool cond, nlstring msg);
static bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep);
static bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep);
static intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4);
static void nelua_assert_line_74(bool cond, nlstring msg);
static intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep);
static intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep);
static intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what);
static void nelua_assert_line_75(bool cond, nlstring msg);
static intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8);
static void nelua_assert_line_76(bool cond, nlstring msg);
static intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l);
static void nelua_assert_line_77(bool cond, nlstring msg);
static void nelua_assert_line_78(bool cond, nlstring msg);
static void nelua_assert_line_79(bool cond, nlstring msg);
typedef struct nlmulret_nlisize_nlisize {
  intptr_t r1;
  intptr_t r2;
} nlmulret_nlisize_nlisize;
static nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s);
typedef struct nlmulret_nlboolean_nelua_sequence_string_ {
  bool r1;
  nelua_sequence_string_ r2;
} nlmulret_nlboolean_nelua_sequence_string_;
static nlmulret_nlboolean_nelua_sequence_string_ nelua_string_match_1(nlstring s, nlstring pattern, nlniltype init);
static void nelua_assert_line_80(bool cond, nlstring msg);
static void nelua_assert_line_81(bool cond, nlstring msg);
static nlmulret_nlboolean_nelua_sequence_string_ nelua_nlstring_match_1(nlstring s, nlstring pattern, nlniltype init);
static nlstring nelua_tostring_3(int64_t x);
static int64_t nelua_tointeger_1(nlstring x, nlniltype base);
static void nelua_assert_line_82(bool cond, nlstring msg);
static nelua_sequence_string__1 nelua_arg;
static int nelua_argc;
typedef char** nlcstring_arr0_ptr;
static nlcstring_arr0_ptr nelua_argv;
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
static nelua_sequence_string__1 nelua_require_arg(nlniltype modname);
static nlstring main_usageStr;
static void nelua_print_1(nlstring a1);
typedef struct nelua_filestream nelua_filestream;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
NELUA_STATIC_ASSERT(sizeof(nelua_filestream) == 8 && NELUA_ALIGNOF(nelua_filestream) == 8, "Nelua and C disagree on type size or align");
typedef int (*function_3W1frj6TeMnyakpkp)(FILE_ptr);
static nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_3W1frj6TeMnyakpkp closef);
typedef nelua_filestream* nelua_filestream_ptr;
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
typedef struct nlmulret_nelua_filestream_nlstring_nlint64 {
  nelua_filestream r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nelua_filestream_nlstring_nlint64;
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlniltype mode);
static NELUA_INLINE char* nelua_assert_string2cstring(nlstring s);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self);
typedef struct nlmulret_nlint64_nlstring_nlint64 {
  int64_t r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlint64_nlstring_nlint64;
static nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_1(nelua_filestream_ptr self, nlstring whence, nlniltype offset);
static nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_2(nelua_filestream_ptr self, nlniltype whence, nlniltype offset);
static nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_3(nelua_filestream_ptr self, nlstring whence, int64_t offset);
typedef struct nlmulret_nlboolean_nlstring {
  bool r1;
  nlstring r2;
} nlmulret_nlboolean_nlstring;
static nlmulret_nlboolean_nlstring nelua_readchars(nelua_stringbuilderT_ptr sb, FILE_ptr fp, uintptr_t n);
typedef struct nlmulret_nlstring_nlstring_nlint64 {
  nlstring r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlstring_nlstring_nlint64;
static nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, int64_t fmt);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static bool nelua_filestream_isopen(nelua_filestream_ptr self);
static nelua_FStream nelua_stderrfs;
static nelua_filestream nelua_io_stderr;
static nlmulret_nlstring_nlint64 nelua_geterrno_1(void);
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlniltype mode);
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_popen_1(nlstring prog, nlniltype mode);
typedef int (*function_2BF7i3e13pYtjRHM2)(FILE_ptr);
static nltype nelua_require_io(nlniltype modname);
static NELUA_NORETURN void nelua_os_exit_1(int64_t code);
static NELUA_INLINE int nelua_assert_narrow_nlint64_nlcint(int64_t x);
static int64_t common_curLine = 1;
static nlstring common_filein;
static nelua_sequence_uint8_ common_program;
static uint64_t common_stringLen;
static NELUA_INLINE int64_t common_getProgramSize(void);
static void common_rasmError_1(nlstring str, nlniltype code);
static void common_rasmError_2(nlstring str, uint8_t code);
static nlstring common_parseString(nlstring str);
static nlstring argHandling_fileout;
static nlstring argHandling_execPath;
typedef struct record_49L3xTLzgx2WKnX6e record_49L3xTLzgx2WKnX6e;
struct record_49L3xTLzgx2WKnX6e {
  bool dump;
  bool strip;
  bool bit32;
};
NELUA_STATIC_ASSERT(sizeof(record_49L3xTLzgx2WKnX6e) == 3 && NELUA_ALIGNOF(record_49L3xTLzgx2WKnX6e) == 1, "Nelua and C disagree on type size or align");
static record_49L3xTLzgx2WKnX6e argHandling_execArgs = {.strip = true};
static bool argHandling_skipArg = false;
static nelua_hashmap_uint8__V_ argHandling_opt;
static void argHandling_handleOpt(uint8_t char_, uint64_t i);
typedef bool* nlboolean_ptr;
static NELUA_INLINE bool nelua_eq_nlisize_nluint64(intptr_t a, uint64_t b);
static NELUA_INLINE uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x);
static void nelua_require_argHandling(nlniltype modname);
static int64_t syntax_fileLen = 0;
static bool syntax_eof = false;
typedef struct syntax_syntax syntax_syntax;
struct syntax_syntax {
  nlstring str;
  uint8_t type;
};
NELUA_STATIC_ASSERT(sizeof(syntax_syntax) == 24 && NELUA_ALIGNOF(syntax_syntax) == 8, "Nelua and C disagree on type size or align");
static syntax_syntax syntax_Parse(nelua_filestream file);
static nelua_hashmap_string__V_ label_labels;
static void nelua_require_label(nlniltype modname);
static nelua_hashmap_string__V__1 instr_instruction;
static uint64_t instr_getArg(nlstring str);
static nluint8_arr4 instr_getInstr(nlstring mnemonic, nelua_sequence_uint64_ args);
static NELUA_INLINE uint32_t nelua_assert_narrow_nluint64_nluint32(uint64_t x);
static void nelua_require_base(nlniltype modname);
static void nelua_require_multiply(nlniltype modname);
static nelua_hashmap_string__V__2 pseudo_pseudoInstr;
static int64_t pseudo_infiniteSize = 0xff;
static nelua_sequence_uint8_ pseudo_concat(nelua_sequence_uint8_ s1, nelua_sequence_uint8_ s2);
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x);
static nelua_sequence_uint8_ pseudo_anonfunc(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_1(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_2(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_3(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_4(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_5(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_6(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_7(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_8(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_9(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_10(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_11(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_12(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_13(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_14(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_15(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_16(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_17(nelua_sequence_uint64_ args);
static NELUA_INLINE uint8_t nelua_assert_narrow_nluint64_nluint8(uint64_t x);
static nelua_sequence_uint8_ pseudo_anonfunc_18(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_19(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_20(nelua_sequence_uint64_ args);
static nelua_sequence_uint8_ pseudo_anonfunc_21(nelua_sequence_uint64_ args);
static void nelua_require_pseudo(nlniltype modname);
static const uint64_t elf_addressOffset = 0x10000U;
static int64_t elf_paddingSize = 16;
static nelua_sequence_elf64Shdr_ elf_shdrs;
static nelua_sequence_elf64Sym_ elf_syms;
typedef struct nelua_sequence_elf64Rel_ nelua_sequence_elf64Rel_;
typedef struct nelua_sequenceimpl_elf64Rel_ nelua_sequenceimpl_elf64Rel_;
typedef nelua_sequenceimpl_elf64Rel_* nelua_sequenceimpl_elf64Rel__ptr;
struct nelua_sequence_elf64Rel_ {
  nelua_sequenceimpl_elf64Rel__ptr impl;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_elf64Rel_) == 8 && NELUA_ALIGNOF(nelua_sequence_elf64Rel_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_elf64Rel_ nelua_span_elf64Rel_;
typedef struct elf_elf64Rel elf_elf64Rel;
typedef elf_elf64Rel* elf_elf64Rel_arr0_ptr;
struct nelua_span_elf64Rel_ {
  elf_elf64Rel_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_elf64Rel_) == 16 && NELUA_ALIGNOF(nelua_span_elf64Rel_) == 8, "Nelua and C disagree on type size or align");
struct nelua_sequenceimpl_elf64Rel_ {
  nelua_span_elf64Rel_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_elf64Rel_) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_elf64Rel_) == 8, "Nelua and C disagree on type size or align");
struct elf_elf64Rel {
  uint64_t r_offset;
  uint64_t r_info;
};
NELUA_STATIC_ASSERT(sizeof(elf_elf64Rel) == 16 && NELUA_ALIGNOF(elf_elf64Rel) == 8, "Nelua and C disagree on type size or align");
static nelua_sequence_elf64Rel_ elf_rels;
static nelua_hashmap_string__uint32_ elf_names;
static int64_t elf_nameLen = 0;
static uint32_t elf_addString(nlstring name);
static NELUA_INLINE uint32_t nelua_assert_narrow_nlint64_nluint32(int64_t x);
static uint32_t elf_addSym(nlstring name, uint8_t info, uint64_t value, uint16_t shindex);
static void elf_addShdr(nlstring name, uint64_t sType, uint32_t flag, uint64_t size, uint64_t offset);
static void elf_writeToFile(nlstring filename, nelua_sequence_uint8_ program_1, uint64_t start);
typedef struct elf_elf64Phdr elf_elf64Phdr;
struct elf_elf64Phdr {
  uint32_t p_type;
  uint32_t p_flags;
  uint64_t p_offset;
  uint64_t p_vuint;
  uint64_t p_puint;
  uint64_t p_filesz;
  uint64_t p_memsz;
  uint64_t p_align;
};
NELUA_STATIC_ASSERT(sizeof(elf_elf64Phdr) == 56 && NELUA_ALIGNOF(elf_elf64Phdr) == 8, "Nelua and C disagree on type size or align");
typedef struct elf_elf64Ehdr elf_elf64Ehdr;
struct elf_elf64Ehdr {
  uint8_t e_ident[16];
  uint16_t eype;
  uint16_t e_machine;
  uint32_t e_version;
  uint64_t e_entry;
  uint64_t e_phoff;
  uint64_t e_shoff;
  uint32_t e_flags;
  uint16_t e_ehsize;
  uint16_t e_phentsize;
  uint16_t e_phnum;
  uint16_t e_shentsize;
  uint16_t e_shnum;
  uint16_t e_shstrndx;
};
NELUA_STATIC_ASSERT(sizeof(elf_elf64Ehdr) == 64 && NELUA_ALIGNOF(elf_elf64Ehdr) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x);
static void nelua_require_elf(nlniltype modname);
static nlstring main_preLabel;
static uint64_t main_addressLabel;
static uint64_t main_preAddressLabel;
static nelua_filestream main_file;
static FILE_ptr main_cfile;
typedef struct NELUA_MAYALIAS nluint8_arr5 {uint8_t v[5];} nluint8_arr5;
typedef union NELUA_MAYALIAS nluint8_arr5_cast {nluint8_arr5 a; uint8_t p[5];} nluint8_arr5_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr5) == 5 && NELUA_ALIGNOF(nluint8_arr5) == 1, "Nelua and C disagree on type size or align");
static nluint8_arr5 main_expects;
static void main_checkSyntax(syntax_syntax syn);
static void main_addLabel(nlstring name, uint64_t value, bool isAddr);
static NELUA_INLINE int64_t nelua_assert_narrow_nluint64_nlint64(uint64_t x);
static nelua_sequence_string_ main_getCallArgs(void);
static nlstring main_lastVar;
static bool main_parseVar(syntax_syntax syn);
static NELUA_INLINE bool nelua_lt_nlisize_nluint8(intptr_t a, uint8_t b);
static NELUA_INLINE bool nelua_lt_nluint8_nlisize(uint8_t a, intptr_t b);
static NELUA_INLINE intptr_t nelua_assert_imod_nlisize(intptr_t a, intptr_t b);
static void main_addInstrToProgram(nluint8_arr4 instr);
static NELUA_INLINE int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len);
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:27:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest and src, 'invalid pointer')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 89, true);
    nelua_abort();
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_1(((dest != NULL) && (src != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memcpy(dest, src, (size_t)n);
}
void nelua_assert_line_2(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:60:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 80, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 73, true);
    nelua_abort();
  }
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_2((dest != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memset(dest, 0, (size_t)n);
}
void nelua_assert_line_3(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:76:11: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(a and b, 'invalid pointer')\n          \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 79, true);
    nelua_abort();
  }
}
int32_t nelua_memory_compare(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return 0;
  }
  nelua_assert_line_3(((a != NULL) && (b != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return (int32_t)memcmp(a, b, (size_t)n);
}
void nelua_assert_line_4(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:89:11: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(a and b, 'invalid pointer')\n          \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 79, true);
    nelua_abort();
  }
}
bool nelua_memory_equals(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return true;
  }
  nelua_assert_line_4(((a != NULL) && (b != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return (memcmp(a, b, (size_t)n) == 0);
}
void nelua_assert_line_5(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:116:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(haystack and needle, 'invalid pointer')\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~\033[0m\n", 107, true);
    nelua_abort();
  }
}
void nelua_panic_cstring(const char* s) {
  if(s) {
    nelua_write_stderr(s, strlen(s), true);
  }
  nelua_abort();
}
void* nelua_assert_deref(void* p) {
  if(NELUA_UNLIKELY(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize) {
  if(NELUA_UNLIKELY(((needlesize == 0) || (haystack == needle)))) {
    return haystack;
  } else if(NELUA_UNLIKELY((needlesize > haystacksize))) {
    return (void*)NULL;
  } else {
    nelua_assert_line_5(((haystack != NULL) && (needle != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
    if((needlesize == 1)) {
      return memchr(haystack, (int)(*(uint8_t*)nelua_assert_deref((nluint8_ptr)needle)), (size_t)haystacksize);
    }
    uintptr_t haystackbegin = (uintptr_t)haystack;
    for(uintptr_t i = haystackbegin, _end = (haystackbegin + (haystacksize - needlesize)); i <= _end; i += 1) {
      void* p = (void*)i;
      if((memcmp(p, needle, (size_t)needlesize) == 0)) {
        return p;
      }
    }
    return (void*)NULL;
  }
}
bool nelua_span_uint8__empty(nelua_span_uint8_ self) {
  return (self.size == 0);
}
void nelua_assert_line_6(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i) {
  nelua_assert_line_6((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_7(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i) {
  nelua_assert_line_7((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_8(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_GCScanRange_ptr nelua_span_GCScanRange____atindex(nelua_span_GCScanRange_ self, uintptr_t i) {
  nelua_assert_line_8((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_9(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i) {
  nelua_assert_line_9((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_10(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i) {
  nelua_assert_line_10((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_11(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__usize__ptr nelua_span_hashmapnode_pointer__usize_____atindex(nelua_span_hashmapnode_pointer__usize__ self, uintptr_t i) {
  nelua_assert_line_11((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_12(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i) {
  nelua_assert_line_12((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_13(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_uint8__V__ptr nelua_span_hashmapnode_uint8__V_____atindex(nelua_span_hashmapnode_uint8__V__ self, uintptr_t i) {
  nelua_assert_line_13((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_14(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_string__V__ptr nelua_span_hashmapnode_string__V_____atindex(nelua_span_hashmapnode_string__V__ self, uintptr_t i) {
  nelua_assert_line_14((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_15(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_string__V__1_ptr nelua_span_hashmapnode_string__V___1___atindex(nelua_span_hashmapnode_string__V___1 self, uintptr_t i) {
  nelua_assert_line_15((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_16(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nluint64_ptr nelua_span_uint64____atindex(nelua_span_uint64_ self, uintptr_t i) {
  nelua_assert_line_16((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_17(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_string__V__2_ptr nelua_span_hashmapnode_string__V___2___atindex(nelua_span_hashmapnode_string__V___2 self, uintptr_t i) {
  nelua_assert_line_17((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_18(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
elf_elf64Shdr_ptr nelua_span_elf64Shdr____atindex(nelua_span_elf64Shdr_ self, uintptr_t i) {
  nelua_assert_line_18((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_19(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
elf_elf64Sym_ptr nelua_span_elf64Sym____atindex(nelua_span_elf64Sym_ self, uintptr_t i) {
  nelua_assert_line_19((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_20(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_string__uint32__ptr nelua_span_hashmapnode_string__uint32_____atindex(nelua_span_hashmapnode_string__uint32__ self, uintptr_t i) {
  nelua_assert_line_20((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to usize failed");
  }
  return (uintptr_t)x;
}
nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next(nlstring_ptr a_1, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_nlstring___len((*(nlstring*)nelua_assert_deref(a_1))) + 1))) {
    return (nlmulret_nlboolean_nlint64_nluint8){false, 0, 0U};
  }
  return (nlmulret_nlboolean_nlint64_nluint8){true, k, (*(uint8_t*)nelua_assert_deref(nelua_nlstring___atindex((*(nlstring*)nelua_assert_deref(a_1)), nelua_assert_narrow_nlint64_nlusize(k))))};
}
nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64 nelua_ipairs_1(nlstring_ptr a) {
  return (nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64){nelua_ipairs_next, a, 0};
}
nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next_1(nelua_sequence_string__1 a_2, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_sequence_string__1___len((&a_2)) + 1))) {
    return (nlmulret_nlboolean_nlint64_nlstring){false, 0, (nlstring){0}};
  }
  nlmulret_nlboolean_nlint64_nlstring _mulret_1;
  _mulret_1.r1 = true;
  _mulret_1.r2 = k;
  _mulret_1.r3 = (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&a_2), nelua_assert_narrow_nlint64_nlusize(k))));
  return _mulret_1;
}
nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64 nelua_ipairs_2(nelua_sequence_string__1 a) {
  return (nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64){nelua_ipairs_next_1, a, 0};
}
nlmulret_nlboolean_nlint64_nluint64 nelua_ipairs_next_2(nelua_sequence_uint64_ a_3, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_sequence_uint64____len((&a_3)) + 1))) {
    return (nlmulret_nlboolean_nlint64_nluint64){false, 0, 0U};
  }
  nlmulret_nlboolean_nlint64_nluint64 _mulret_1;
  _mulret_1.r1 = true;
  _mulret_1.r2 = k;
  _mulret_1.r3 = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&a_3), nelua_assert_narrow_nlint64_nlusize(k))));
  return _mulret_1;
}
nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 nelua_ipairs_3(nelua_sequence_uint64_ a) {
  return (nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64){nelua_ipairs_next_2, a, 0};
}
nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next_3(nelua_sequence_uint8_ a_4, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_sequence_uint8____len((&a_4)) + 1))) {
    return (nlmulret_nlboolean_nlint64_nluint8){false, 0, 0U};
  }
  nlmulret_nlboolean_nlint64_nluint8 _mulret_1;
  _mulret_1.r1 = true;
  _mulret_1.r2 = k;
  _mulret_1.r3 = (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&a_4), nelua_assert_narrow_nlint64_nlusize(k))));
  return _mulret_1;
}
nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64 nelua_ipairs_4(nelua_sequence_uint8_ a) {
  return (nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64){nelua_ipairs_next_3, a, 0};
}
nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer nelua_pairs_1(nelua_hashmap_pointer__usize__ptr a) {
  nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer _ret_1 = nelua_hashmap_pointer__usize____pairs(a);
  return (nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring nelua_pairs_2(nelua_hashmap_string__uint32__ptr a) {
  nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring _ret_1 = nelua_hashmap_string__uint32____pairs(a);
  return (nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i += 1) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(dest, i))) = x;
  }
}
void nelua_sequence_string___init(nelua_sequence_string__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GCAllocator_new_1((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_string__reserve(nelua_sequence_string__ptr self, uintptr_t n) {
  nelua_sequence_string___init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_sequence_string__resize(nelua_sequence_string__ptr self, uintptr_t n) {
  nelua_sequence_string__reserve(self, n);
  if((n > self->impl->size)) {
    nelua_memory_zero((void*)(&(*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, (self->impl->size + 1))))), ((n - self->impl->size) * 16));
  }
  self->impl->size = n;
}
void nelua_assert_line_21(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow(nelua_sequence_string__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_21((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_22(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_sequence_string____atindex(nelua_sequence_string__ptr self, uintptr_t pos) {
  nelua_sequence_string___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_22((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow(self);
    }
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))) = (nlstring){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow(self);
  }
  return (&(*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_string____len(nelua_sequence_string__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_1((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n) {
  nelua_sequence_string__1__init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_23(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_23((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_24(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos) {
  nelua_sequence_string__1__init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_24((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_1(self);
    }
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))) = (nlstring){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_1(self);
  }
  return (&(*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_sequence_uint8___init(nelua_sequence_uint8__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GCAllocator_new_3((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_uint8__reserve(nelua_sequence_uint8__ptr self, uintptr_t n) {
  nelua_sequence_uint8___init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->impl->data, 0U))) = 0U;
  }
}
void nelua_assert_line_25(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_2(nelua_sequence_uint8__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_25((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->impl->data, 0U))) = 0U;
  }
}
void nelua_assert_line_26(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_sequence_uint8____atindex(nelua_sequence_uint8__ptr self, uintptr_t pos) {
  nelua_sequence_uint8___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_26((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_2(self);
    }
    (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->impl->data, pos))) = 0U;
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_2(self);
  }
  return (&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_uint8____len(nelua_sequence_uint8__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nelua_sequence_uint8_ nelua_sequence_uint8____convert_1(nluint8_arr4 values) {
  nelua_sequence_uint8_ self = (nelua_sequence_uint8_){0};
  nelua_sequence_uint8__reserve((&self), 4U);
  self.impl->size = 4U;
  for(uintptr_t i = 1U; i <= 4U; i += 1) {
    (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self.impl->data, i))) = values.v[nelua_assert_bounds_nlusize((i - 1), 4)];
  }
  return self;
}
void nelua_sequence_uint64___init(nelua_sequence_uint64__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GCAllocator_new_4((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_uint64__reserve(nelua_sequence_uint64__ptr self, uintptr_t n) {
  nelua_sequence_uint64___init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self->impl->data, 0U))) = 0U;
  }
}
void nelua_assert_line_27(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_3(nelua_sequence_uint64__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_27((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self->impl->data, 0U))) = 0U;
  }
}
void nelua_assert_line_28(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
nluint64_ptr nelua_sequence_uint64____atindex(nelua_sequence_uint64__ptr self, uintptr_t pos) {
  nelua_sequence_uint64___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_28((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_3(self);
    }
    (*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self->impl->data, pos))) = 0U;
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_3(self);
  }
  return (&(*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_uint64____len(nelua_sequence_uint64__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
nelua_sequence_uint64_ nelua_sequence_uint64____convert_1(nluint64_arr3 values) {
  nelua_sequence_uint64_ self = (nelua_sequence_uint64_){0};
  nelua_sequence_uint64__reserve((&self), 3U);
  self.impl->size = 3U;
  for(uintptr_t i = 1U; i <= 3U; i += 1) {
    (*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self.impl->data, i))) = values.v[nelua_assert_bounds_nlusize((i - 1), 3)];
  }
  return self;
}
nelua_sequence_uint64_ nelua_sequence_uint64____convert_2(nluint64_arr2 values) {
  nelua_sequence_uint64_ self = (nelua_sequence_uint64_){0};
  nelua_sequence_uint64__reserve((&self), 2U);
  self.impl->size = 2U;
  for(uintptr_t i = 1U; i <= 2U; i += 1) {
    (*(uint64_t*)nelua_assert_deref(nelua_span_uint64____atindex(self.impl->data, i))) = values.v[nelua_assert_bounds_nlusize((i - 1), 2)];
  }
  return self;
}
void nelua_sequence_elf64Shdr___init(nelua_sequence_elf64Shdr__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GCAllocator_new_5((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_assert_line_29(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_4(nelua_sequence_elf64Shdr__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_29((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_5((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(elf_elf64Shdr*)nelua_assert_deref(nelua_span_elf64Shdr____atindex(self->impl->data, 0U))) = (elf_elf64Shdr){0};
  }
}
void nelua_assert_line_30(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
elf_elf64Shdr_ptr nelua_sequence_elf64Shdr____atindex(nelua_sequence_elf64Shdr__ptr self, uintptr_t pos) {
  nelua_sequence_elf64Shdr___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_30((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_4(self);
    }
    (*(elf_elf64Shdr*)nelua_assert_deref(nelua_span_elf64Shdr____atindex(self->impl->data, pos))) = (elf_elf64Shdr){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_4(self);
  }
  return (&(*(elf_elf64Shdr*)nelua_assert_deref(nelua_span_elf64Shdr____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_elf64Shdr____len(nelua_sequence_elf64Shdr__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_sequence_elf64Sym___init(nelua_sequence_elf64Sym__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GCAllocator_new_6((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_assert_line_31(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:151:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_5(nelua_sequence_elf64Sym__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_31((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GCAllocator_xspanrealloc_6((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(elf_elf64Sym*)nelua_assert_deref(nelua_span_elf64Sym____atindex(self->impl->data, 0U))) = (elf_elf64Sym){0};
  }
}
void nelua_assert_line_32(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:259:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
elf_elf64Sym_ptr nelua_sequence_elf64Sym____atindex(nelua_sequence_elf64Sym__ptr self, uintptr_t pos) {
  nelua_sequence_elf64Sym___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_32((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_5(self);
    }
    (*(elf_elf64Sym*)nelua_assert_deref(nelua_span_elf64Sym____atindex(self->impl->data, pos))) = (elf_elf64Sym){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_5(self);
  }
  return (&(*(elf_elf64Sym*)nelua_assert_deref(nelua_span_elf64Sym____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_elf64Sym____len(nelua_sequence_elf64Sym__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GeneralAllocator_alloc0_1(self, size, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc_2(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){.data = data, .size = size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_1 = 262144U;
    nelua_GCScanRange_arr0_ptr data = ((nelua_GCScanRange_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 16), flags_1));
    if(NELUA_LIKELY((data != ((nelua_GCScanRange_arr0_ptr)NULL)))) {
      return (nelua_span_GCScanRange_){.data = data, .size = size};
    }
  }
  return (nelua_span_GCScanRange_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_2 = 262144U;
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), flags_2));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_string_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GeneralAllocator_alloc_2(self, (size * 16), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){.data = data, .size = size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 56), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__usize__arr0_ptr data = ((nelua_hashmapnode_pointer__usize__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 32), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__usize__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__usize__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_pointer__usize__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_GCScanRange_arr0_ptr p = ((nelua_GCScanRange_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_GCScanRange_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_4(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 56), (s.size * 56)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_pointer__usize__arr0_ptr p = ((nelua_hashmapnode_pointer__usize__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__usize__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_xspanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_string__1_ptr ptr = ((nelua_sequenceimpl_string__1_ptr)nelua_GeneralAllocator_xalloc0_1(self, 24U, NELUA_NIL));
  return ptr;
}
uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step) {
  seed = (seed ^ len);
  while((len >= step)) {
    seed = (seed ^ (((seed << 5) + (seed >> 2)) + data[(len - 1)]));
    len = (len - step);
  }
  return seed;
}
uintptr_t nelua_hash_long(nelua_span_uint8_ data) {
  return nelua_lhash(data.data, data.size, 0x9e3779b9ULL, ((data.size >> 5) + 1));
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 4);
}
uintptr_t nelua_hash_hash_2(uint8_t v) {
  return (uintptr_t)v;
}
uintptr_t nelua_hash_hash_3(nlstring v) {
  return nelua_hash_long((nelua_span_uint8_){.data = v.data, .size = v.size});
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h & (n - 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_4((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_33(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
    nelua_assert_line_33((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_34(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_assert_line_34((node_index_1 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index_1))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_1;
    } else {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, nelua_hashmap_pointer__GCItem___at(self, key)))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
  nelua_GCItem value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
bool nelua_hashmap_pointer__GCItem__erase(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return false;
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return true;
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_pointer__GCItem__ptr)NULL);
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  nelua_hashmapnode_pointer__GCItem__ptr node = nelua_hashmap_iteratorT__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
}
nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
void nelua_hashmap_pointer__usize__destroy(nelua_hashmap_pointer__usize__ptr self) {
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_5((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__usize__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__usize___find(nelua_hashmap_pointer__usize__ptr self, void* key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_35(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__usize__rehash(nelua_hashmap_pointer__usize__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))) = (nelua_hashmapnode_pointer__usize_){0};
    }
    nelua_assert_line_35((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_2((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_36(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__usize___at(nelua_hashmap_pointer__usize__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__usize__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_2 = self->free_index;
    nelua_assert_line_36((node_index_2 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index_2))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__usize_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_2;
    } else {
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = node_index_2;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__usize__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_2;
  }
}
nlusize_ptr nelua_hashmap_pointer__usize____atindex(nelua_hashmap_pointer__usize__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, nelua_hashmap_pointer__usize___at(self, key)))).value);
}
uintptr_t nelua_hashmap_pointer__usize__remove(nelua_hashmap_pointer__usize__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return 0U;
  }
  nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index))));
  uintptr_t value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__usize_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
nelua_hashmapnode_pointer__usize__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_pointer__usize__ptr)NULL);
}
nlmulret_nlboolean_nlpointer_nlusize nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, void* key) {
  nelua_hashmapnode_pointer__usize__ptr node = nelua_hashmap_iteratorT_1__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlpointer_nlusize){false, NULL, 0U};
  }
  return (nlmulret_nlboolean_nlpointer_nlusize){true, node->key, node->value};
}
nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer nelua_hashmap_pointer__usize____pairs(nelua_hashmap_pointer__usize__ptr self) {
  return (nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer){nelua_hashmap_iteratorT_1_next, (nelua_hashmap_iteratorT_1){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_uint8__V___find(nelua_hashmap_uint8__V__ptr self, uint8_t key) {
  uintptr_t h = nelua_hash_hash_2(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_uint8__V__ptr node = (&(*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_37(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_uint8__V__rehash(nelua_hashmap_uint8__V__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i))) = (nelua_hashmapnode_uint8__V_){0};
    }
    nelua_assert_line_37((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_uint8__V__ptr node = (&(*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_uint8__V___find(self, (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_38(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_uint8__V___at(nelua_hashmap_uint8__V__ptr self, uint8_t key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_uint8__V__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_uint8__V___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_3 = self->free_index;
    nelua_assert_line_38((node_index_3 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_uint8__V__ptr node = (&(*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, node_index_3))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(node)) = (nelua_hashmapnode_uint8__V_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_3;
    } else {
      (*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, prev_node_index))).next = node_index_3;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_uint8__V__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_3;
  }
}
nelua_V_2_ptr nelua_hashmap_uint8__V____atindex(nelua_hashmap_uint8__V__ptr self, uint8_t key) {
  return (&(*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, nelua_hashmap_uint8__V___at(self, key)))).value);
}
nelua_V_2_ptr nelua_hashmap_uint8__V__peek(nelua_hashmap_uint8__V__ptr self, uint8_t key) {
  uintptr_t node_index = nelua_hashmap_uint8__V___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_uint8__V_*)nelua_assert_deref(nelua_span_hashmapnode_uint8__V_____atindex(self->nodes, node_index))).value);
  }
  return ((nelua_V_2_ptr)NULL);
}
bool nelua_hashmap_uint8__V__has(nelua_hashmap_uint8__V__ptr self, uint8_t key) {
  return (nelua_hashmap_uint8__V__peek(self, key) != ((nelua_V_2_ptr)NULL));
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V___find(nelua_hashmap_string__V__ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_3(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__V__ptr node = (&(*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, node_index))));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_39(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_string__V__rehash(nelua_hashmap_string__V__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i))) = (nelua_hashmapnode_string__V_){0};
    }
    nelua_assert_line_39((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_2((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__V__ptr node = (&(*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V___find(self, (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_40(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_string__V___at(nelua_hashmap_string__V__ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__V__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_4 = self->free_index;
    nelua_assert_line_40((node_index_4 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_string__V__ptr node = (&(*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, node_index_4))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(node)) = (nelua_hashmapnode_string__V_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_4;
    } else {
      (*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, prev_node_index))).next = node_index_4;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__V__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_4;
  }
}
nelua_V_3_ptr nelua_hashmap_string__V____atindex(nelua_hashmap_string__V__ptr self, nlstring key) {
  return (&(*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, nelua_hashmap_string__V___at(self, key)))).value);
}
nelua_V_3_ptr nelua_hashmap_string__V__peek(nelua_hashmap_string__V__ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__V___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_string__V_*)nelua_assert_deref(nelua_span_hashmapnode_string__V_____atindex(self->nodes, node_index))).value);
  }
  return ((nelua_V_3_ptr)NULL);
}
bool nelua_hashmap_string__V__has(nelua_hashmap_string__V__ptr self, nlstring key) {
  return (nelua_hashmap_string__V__peek(self, key) != ((nelua_V_3_ptr)NULL));
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V__1__find(nelua_hashmap_string__V__1_ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_3(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__V__1_ptr node = (&(*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, node_index))));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_41(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_string__V__1_rehash(nelua_hashmap_string__V__1_ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, j))) = (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i))) = (nelua_hashmapnode_string__V__1){0};
    }
    nelua_assert_line_41((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_3((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__V__1_ptr node = (&(*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V__1__find(self, (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_42(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_string__V__1__at(nelua_hashmap_string__V__1_ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__V__1_rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V__1__find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_5 = self->free_index;
    nelua_assert_line_42((node_index_5 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_string__V__1_ptr node = (&(*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, node_index_5))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(node)) = (nelua_hashmapnode_string__V__1){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_5;
    } else {
      (*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, prev_node_index))).next = node_index_5;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__V__1_rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_5;
  }
}
nelua_V_4_ptr nelua_hashmap_string__V__1___atindex(nelua_hashmap_string__V__1_ptr self, nlstring key) {
  return (&(*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, nelua_hashmap_string__V__1__at(self, key)))).value);
}
nelua_V_4_ptr nelua_hashmap_string__V__1_peek(nelua_hashmap_string__V__1_ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__V__1__find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_string__V__1*)nelua_assert_deref(nelua_span_hashmapnode_string__V___1___atindex(self->nodes, node_index))).value);
  }
  return ((nelua_V_4_ptr)NULL);
}
bool nelua_hashmap_string__V__1_has(nelua_hashmap_string__V__1_ptr self, nlstring key) {
  return (nelua_hashmap_string__V__1_peek(self, key) != ((nelua_V_4_ptr)NULL));
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__V__2__find(nelua_hashmap_string__V__2_ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_3(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__V__2_ptr node = (&(*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, node_index))));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_43(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_string__V__2_rehash(nelua_hashmap_string__V__2_ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, j))) = (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i))) = (nelua_hashmapnode_string__V__2){0};
    }
    nelua_assert_line_43((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_4((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__V__2_ptr node = (&(*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V__2__find(self, (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_44(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_string__V__2__at(nelua_hashmap_string__V__2_ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__V__2_rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__V__2__find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_6 = self->free_index;
    nelua_assert_line_44((node_index_6 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_string__V__2_ptr node = (&(*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, node_index_6))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(node)) = (nelua_hashmapnode_string__V__2){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_6;
    } else {
      (*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, prev_node_index))).next = node_index_6;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__V__2_rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_6;
  }
}
nelua_V_5_ptr nelua_hashmap_string__V__2___atindex(nelua_hashmap_string__V__2_ptr self, nlstring key) {
  return (&(*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, nelua_hashmap_string__V__2__at(self, key)))).value);
}
nelua_V_5_ptr nelua_hashmap_string__V__2_peek(nelua_hashmap_string__V__2_ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__V__2__find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_string__V__2*)nelua_assert_deref(nelua_span_hashmapnode_string__V___2___atindex(self->nodes, node_index))).value);
  }
  return ((nelua_V_5_ptr)NULL);
}
bool nelua_hashmap_string__V__2_has(nelua_hashmap_string__V__2_ptr self, nlstring key) {
  return (nelua_hashmap_string__V__2_peek(self, key) != ((nelua_V_5_ptr)NULL));
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__uint32___find(nelua_hashmap_string__uint32__ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_3(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__uint32__ptr node = (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, node_index))));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_45(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_string__uint32__rehash(nelua_hashmap_string__uint32__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i))) = (nelua_hashmapnode_string__uint32_){0};
    }
    nelua_assert_line_45((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_5((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__uint32__ptr node = (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__uint32___find(self, (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_46(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_string__uint32___at(nelua_hashmap_string__uint32__ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__uint32__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__uint32___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_7 = self->free_index;
    nelua_assert_line_46((node_index_7 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_string__uint32__ptr node = (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, node_index_7))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(node)) = (nelua_hashmapnode_string__uint32_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_7;
    } else {
      (*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, prev_node_index))).next = node_index_7;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__uint32__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_7;
  }
}
nluint32_ptr nelua_hashmap_string__uint32____atindex(nelua_hashmap_string__uint32__ptr self, nlstring key) {
  return (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, nelua_hashmap_string__uint32___at(self, key)))).value);
}
nluint32_ptr nelua_hashmap_string__uint32__peek(nelua_hashmap_string__uint32__ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__uint32___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->nodes, node_index))).value);
  }
  return (nluint32_ptr)NULL;
}
bool nelua_hashmap_string__uint32__has(nelua_hashmap_string__uint32__ptr self, nlstring key) {
  return (nelua_hashmap_string__uint32__peek(self, key) != (nluint32_ptr)NULL);
}
nelua_hashmapnode_string__uint32__ptr nelua_hashmap_iteratorT_6__next_node(nelua_hashmap_iteratorT_6_ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_string__uint32__ptr node = (&(*(nelua_hashmapnode_string__uint32_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint32_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_string__uint32__ptr)NULL);
}
nlmulret_nlboolean_nlstring_nluint32 nelua_hashmap_iteratorT_6_next(nelua_hashmap_iteratorT_6_ptr self, nlstring key) {
  nelua_hashmapnode_string__uint32__ptr node = nelua_hashmap_iteratorT_6__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlstring_nluint32){false, (nlstring){0}, 0U};
  }
  return (nlmulret_nlboolean_nlstring_nluint32){true, node->key, node->value};
}
nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring nelua_hashmap_string__uint32____pairs(nelua_hashmap_string__uint32__ptr self) {
  return (nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring){nelua_hashmap_iteratorT_6_next, (nelua_hashmap_iteratorT_6){.container = self, .index = 0xffffffffffffffffULL}, (nlstring){0}};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = 0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = 0U;
}
void nelua_assert_line_47(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:124:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_47((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_48(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:223:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos) {
  nelua_assert_line_48((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, pos))));
}
void nelua_vector_GCScanRange__destroy(nelua_vector_GCScanRange__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->data);
  self->data = (nelua_span_GCScanRange_){0};
  self->size = 0U;
}
void nelua_assert_line_49(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:124:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_1(nelua_vector_GCScanRange__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_49((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->data, cap);
}
void nelua_vector_GCScanRange__push(nelua_vector_GCScanRange__ptr self, nelua_GCScanRange v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_1(self);
  }
  (*(nelua_GCScanRange*)nelua_assert_deref(nelua_span_GCScanRange____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_50(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:144:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(self.size > 0, 'attempt to pop an empty vector')\n                    \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
nelua_GCScanRange nelua_vector_GCScanRange__pop(nelua_vector_GCScanRange__ptr self) {
  nelua_assert_line_50((self->size > 0), ((nlstring){(uint8_t*)"attempt to pop an empty vector", 30}));
  self->size = (self->size - 1);
  return (*(nelua_GCScanRange*)nelua_assert_deref(nelua_span_GCScanRange____atindex(self->data, self->size)));
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align) {
  return ((addr + (align - 1)) & (~(align - 1)));
}
void nelua_assert_line_51(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:140:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(oldsize ~= 0, 'invalid unregister pointer')\n                   \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
  if(NELUA_LIKELY((item.size != 0))) {
    self->membytes = (self->membytes - item.size);
    for(uintptr_t i = 0U, _end = self->finalizeitems.size; i < _end; i += 1) {
      if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) == ptr)) {
        (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) = (void*)NULL;
        break;
      }
    }
    if((finalize && (item.finalizer != NULL))) {
      item.finalizer(ptr, item.userdata);
    }
  } else {
    uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), ptr);
    nelua_assert_line_51((oldsize != 0), ((nlstring){(uint8_t*)"invalid unregister pointer", 26}));
  }
}
void nelua_GC_markptrs(nelua_GC_ptr self) {
  uintptr_t addrtestmask = ((~self->addrormask) | self->addrandmask);
  uintptr_t addrandmask = self->addrandmask;
  while((self->scanranges.size > 0)) {
    nelua_GCScanRange range = nelua_vector_GCScanRange__pop((&self->scanranges));
    for(uintptr_t memaddr = range.low, _end = range.high; memaddr < _end; memaddr += 8) {
      uintptr_t addr = (*(uintptr_t*)nelua_assert_deref((nlusize_ptr)memaddr));
      if(((addr & addrtestmask) == addrandmask)) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), (void*)addr);
        if(((item != NULL) && (!nelua_hasflag(item->flags, 65536U)))) {
          item->flags = (item->flags | 65536U);
          if((!nelua_hasflag(item->flags, 262144U))) {
            nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item->size)});
          }
        }
      }
    }
  }
}
void nelua_GC_scanrange(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){low, high});
}
void nelua_GC_scanptr(nelua_GC_ptr self, void* ptr) {
  nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
  if(((item != NULL) && (!nelua_hasflag(item->flags, 65536U)))) {
    item->flags = (item->flags | 65536U);
    if((!nelua_hasflag(item->flags, 262144U))) {
      uintptr_t addr = (uintptr_t)ptr;
      nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item->size)});
    }
  }
}
void nelua_GC_scanstack(nelua_GC_ptr self) {
  nelua_RegsBuf regsbuf;
  setjmp(regsbuf.regs);
#if defined(__GNUC__) || defined(__clang__)
  void* sp = __builtin_frame_address(0);
#endif
  uintptr_t low = ((self->stacktop == 0) ? (uintptr_t)(&regsbuf) : self->stacktop);
  uintptr_t high = self->stackbottom;
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  low = nelua_align_forward(low, 8U);
  nelua_GC_scanrange(self, low, high);
  nelua_GC_scanrange(self, (uintptr_t)(&regsbuf), ((uintptr_t)(&regsbuf) + (uintptr_t)sizeof(nelua_RegsBuf)));
#if defined(__GNUC__) || defined(__clang__)
  nelua_GC_scanptr(self, sp);
#endif
}
void nelua_GC_mark(nelua_GC_ptr self) {
  {
    nlmulret_function_2mALLZkSFbNDkE6o4_nelua_hashmap_iteratorT_1_nlpointer _asgnret_1 = nelua_pairs_1((&self->rootitems));
    function_2mALLZkSFbNDkE6o4 __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT_1 __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nlusize _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      uintptr_t item_size = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        uintptr_t addr = (uintptr_t)ptr;
        nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item_size)});
      }
    }
  }
  if((self->stackbottom != 0)) {
    volatile function_2jfxAcq6U1dnkseqH scanstack = nelua_GC_scanstack;
    scanstack(self);
  }
  nelua_GC_markptrs(self);
}
void nelua_assert_line_52(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:247:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(removed, 'gc item not found to erase')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
void nelua_assert_line_53(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:260:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(item ~= nilptr, 'gc item not found to finalize')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_assert_line_54(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:275:23: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(item.size ~= 0, 'gc item not found to deallocate')\n                      \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 117, true);
    nelua_abort();
  }
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  uintptr_t membytes = self->membytes;
  {
    nlmulret_function_4vXvvEhXfi6WJuzfV_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_4vXvvEhXfi6WJuzfV __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      nelua_GCItem_ptr item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        uintptr_t item_flags = item->flags;
        if(nelua_hasflag(item_flags, 65536U)) {
          item->flags = (item_flags & 18446744073709486079ULL);
        } else if(NELUA_UNLIKELY(nelua_hasflag(item_flags, 131072U))) {
          nelua_vector_pointer__push((&self->finalizeitems), ptr);
        } else {
          membytes = (membytes - item->size);
          bool removed = nelua_hashmap_pointer__GCItem__erase((&self->items), ptr);
          nelua_assert_line_52(removed, ((nlstring){(uint8_t*)"gc item not found to erase", 26}));
          if(NELUA_LIKELY((!nelua_hasflag(item_flags, 1048576U)))) {
            nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
          }
        }
      }
    }
  }
  self->membytes = membytes;
  uintptr_t i = 0U;
  while((i < self->finalizeitems.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i)));
    if(NELUA_LIKELY((ptr != NULL))) {
      nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
      nelua_assert_line_53((item != ((nelua_GCItem_ptr)NULL)), ((nlstring){(uint8_t*)"gc item not found to finalize", 29}));
      if(NELUA_LIKELY(((item != NULL) && (item->finalizer != NULL)))) {
        nelua_GCFinalizerCallback finalizer = item->finalizer;
        item->finalizer = (nelua_GCFinalizerCallback)NULL;
        finalizer(ptr, item->userdata);
      }
    }
    i = (i + 1);
  }
  uintptr_t i_1 = 0U;
  while((i_1 < self->finalizeitems.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i_1)));
    if(NELUA_LIKELY((ptr != NULL))) {
      nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
      nelua_assert_line_54((item.size != 0), ((nlstring){(uint8_t*)"gc item not found to deallocate", 31}));
      if(NELUA_LIKELY((item.size != 0))) {
        self->membytes = (self->membytes - item.size);
        if(NELUA_UNLIKELY((!nelua_hasflag(item.flags, 1048576U)))) {
          nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
        }
      }
    }
    i_1 = (i_1 + 1);
  }
  nelua_vector_pointer__clear((&self->finalizeitems));
}
void nelua_GC_rehash(nelua_GC_ptr self) {
  if((((self->items.size * 4) < self->items.buckets.size) && (self->items.buckets.size > 8))) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  if((((self->rootitems.size * 4) < self->rootitems.buckets.size) && (self->rootitems.buckets.size > 8))) {
    nelua_hashmap_pointer__usize__rehash((&self->rootitems), 0U);
  }
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  nelua_GC_rehash(self);
  self->lastmembytes = self->membytes;
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&nelua_arg), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_usageStr), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&common_filein), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&common_program), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&argHandling_fileout), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&argHandling_execPath), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&label_labels), 48U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&instr_instruction), 48U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&pseudo_pseudoInstr), 48U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stderr), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_preLabel), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_file), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_cfile), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_lastVar), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stderrfs), 16U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&argHandling_opt), 48U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&elf_shdrs), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&elf_syms), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&elf_rels), 8U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&elf_names), 48U, 131072U, (function_2JB2mT5p6U8prYAPj)NULL, (void*)NULL);
}
bool nelua_GC_step(nelua_GC_ptr self) {
  if(((!self->collecting) && ((self->membytes * 100) >= (self->lastmembytes * self->pause)))) {
    nelua_GC_collect(self);
    return true;
  }
  return false;
}
void nelua_assert_line_55(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:382:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(size > 0, 'attempt to register a pointer with size zero')\n              \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 112, true);
    nelua_abort();
  }
}
void nelua_assert_line_56(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:389:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(item.size == 0, 'cannot register pointer twice')\n                    \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 111, true);
    nelua_abort();
  }
}
void nelua_assert_line_57(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:406:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(flags == GCFlags.ROOT, 'attempt to register a root pointer with invalid flags')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 151, true);
    nelua_abort();
  }
}
void nelua_assert_line_58(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:407:32: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(finalizer == nilptr and userdata == nilptr, 'attempt to register a root pointer with finalizer')\n                               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 189, true);
    nelua_abort();
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2JB2mT5p6U8prYAPj finalizer, void* userdata) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  nelua_assert_line_55((size > 0), ((nlstring){(uint8_t*)"attempt to register a pointer with size zero", 44}));
  if(NELUA_LIKELY((!nelua_hasflag(flags, 131072U)))) {
    if(NELUA_UNLIKELY((size < 8))) {
      flags = (flags | 262144U);
    }
    if(NELUA_UNLIKELY((finalizer != NULL))) {
      flags = (flags | 131072U);
    }
    nelua_GCItem_ptr item = (&(*(nelua_GCItem*)nelua_assert_deref(nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr))));
    nelua_assert_line_56((item->size == 0), ((nlstring){(uint8_t*)"cannot register pointer twice", 29}));
    (*(nelua_GCItem*)nelua_assert_deref(item)) = (nelua_GCItem){.flags = flags, .size = size, .finalizer = finalizer, .userdata = userdata};
    uintptr_t addr = (uintptr_t)ptr;
    self->addrormask = (self->addrormask | addr);
    self->addrandmask = (self->addrandmask & addr);
    self->membytes = (self->membytes + size);
    if(NELUA_LIKELY(self->running)) {
      nelua_GC_step(self);
    }
  } else {
    nelua_assert_line_57((flags == 131072U), ((nlstring){(uint8_t*)"attempt to register a root pointer with invalid flags", 53}));
    nelua_assert_line_58(((finalizer == (function_2JB2mT5p6U8prYAPj)NULL) && (userdata == (void*)NULL)), ((nlstring){(uint8_t*)"attempt to register a root pointer with finalizer", 49}));
    (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), ptr))) = size;
  }
}
void nelua_assert_line_59(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:417:47: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(oldptr ~= nilptr and newptr ~= nilptr and newsize > 0, 'invalid reregister arguments')\n                                              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 184, true);
    nelua_abort();
  }
}
void nelua_assert_line_60(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:433:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(oldsize ~= 0, 'invalid reregister pointer')\n                     \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
void nelua_assert_line_61(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:452:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(oldsize ~= 0, 'invalid reregister pointer')\n                     \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize) {
  nelua_assert_line_59((((oldptr != (void*)NULL) && (newptr != (void*)NULL)) && (newsize > 0)), ((nlstring){(uint8_t*)"invalid reregister arguments", 28}));
  if((newptr == oldptr)) {
    nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), oldptr);
    if(NELUA_LIKELY((item != NULL))) {
      uintptr_t oldsize = item->size;
      item->size = newsize;
      if(NELUA_LIKELY((newsize > oldsize))) {
        self->membytes = (self->membytes + (newsize - oldsize));
        if(NELUA_LIKELY(self->running)) {
          nelua_GC_step(self);
        }
      } else if((newsize < oldsize)) {
        self->membytes = (self->membytes - (oldsize - newsize));
      }
    } else {
      uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), oldptr);
      nelua_assert_line_60((oldsize != 0), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
      (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), newptr))) = newsize;
    }
  } else {
    nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), oldptr);
    if(NELUA_LIKELY((item.size != 0))) {
      uintptr_t oldsize = item.size;
      self->membytes = (self->membytes - oldsize);
      for(uintptr_t i = 0U, _end = self->finalizeitems.size; i < _end; i += 1) {
        if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) == oldptr)) {
          (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) = newptr;
          break;
        }
      }
      nelua_GC_register(self, newptr, newsize, item.flags, item.finalizer, item.userdata);
    } else {
      uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), oldptr);
      nelua_assert_line_61((oldsize != 0), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
      (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), newptr))) = newsize;
    }
  }
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = (uintptr_t)stack;
  self->addrandmask = 0xffffffffffffffffULL;
  self->pause = 200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  self->collecting = true;
  nelua_GC_sweep(self);
  self->collecting = false;
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_hashmap_pointer__usize__destroy((&self->rootitems));
  nelua_vector_pointer__destroy((&self->finalizeitems));
  nelua_vector_GCScanRange__destroy((&self->scanranges));
  (*(nelua_GC*)nelua_assert_deref(self)) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_3p2TXK13e3jRvktoU inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_3 = 0U;
  nelua_GCFinalizerCallback finalizer_1 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_1 = (void*)NULL;
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags_3);
  nelua_GC_register((&nelua_gc), ptr, size, flags_3, finalizer_1, userdata_1);
  return ptr;
}
void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_4 = 0U;
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags_4);
  nelua_GC_register((&nelua_gc), ptr, size, flags_4, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_5 = 0U;
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags_5);
  nelua_GC_register((&nelua_gc), ptr, size, flags_5, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr) {
  nelua_GC_unregister_1((&nelua_gc), ptr, true);
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
}
void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((ptr == (void*)NULL))) {
    return nelua_GCAllocator_alloc_1(self, newsize, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  } else if(NELUA_UNLIKELY((newsize == 0))) {
    nelua_GCAllocator_dealloc(self, ptr);
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return ptr;
  } else {
    void* newptr = nelua_GeneralAllocator_realloc((&nelua_general_allocator), ptr, newsize, oldsize);
    if(NELUA_LIKELY((newptr != NULL))) {
      nelua_GC_reregister((&nelua_gc), ptr, newptr, newsize);
    }
    return newptr;
  }
}
nelua_span_string_ nelua_GCAllocator_spanalloc_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_2 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_2 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 16), NELUA_NIL, finalizer_2, userdata_2));
    if(NELUA_LIKELY((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){.data = data, .size = size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_6 = 262144U;
  nelua_GCFinalizerCallback finalizer_3 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_3 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 1), flags_6, finalizer_3, userdata_3));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_uint64_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_7 = 262144U;
  nelua_GCFinalizerCallback finalizer_4 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_4 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint64_arr0_ptr data = ((nluint64_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 8), flags_7, finalizer_4, userdata_4));
    if(NELUA_LIKELY((data != ((nluint64_arr0_ptr)NULL)))) {
      return (nelua_span_uint64_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint64_){0};
}
nelua_span_elf64Shdr_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_8 = 262144U;
  nelua_GCFinalizerCallback finalizer_5 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_5 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    elf_elf64Shdr_arr0_ptr data = ((elf_elf64Shdr_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 64), flags_8, finalizer_5, userdata_5));
    if(NELUA_LIKELY((data != ((elf_elf64Shdr_arr0_ptr)NULL)))) {
      return (nelua_span_elf64Shdr_){.data = data, .size = size};
    }
  }
  return (nelua_span_elf64Shdr_){0};
}
nelua_span_elf64Sym_ nelua_GCAllocator_spanalloc_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_9 = 262144U;
  nelua_GCFinalizerCallback finalizer_6 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_6 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    elf_elf64Sym_arr0_ptr data = ((elf_elf64Sym_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 24), flags_9, finalizer_6, userdata_6));
    if(NELUA_LIKELY((data != ((elf_elf64Sym_arr0_ptr)NULL)))) {
      return (nelua_span_elf64Sym_){.data = data, .size = size};
    }
  }
  return (nelua_span_elf64Sym_){0};
}
nelua_span_usize_ nelua_GCAllocator_spanalloc_7(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_10 = 262144U;
  nelua_GCFinalizerCallback finalizer_7 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_7 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 8), flags_10, finalizer_7, userdata_7));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_11 = 262144U;
  nelua_GCFinalizerCallback finalizer_8 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_8 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc0_2(self, (size * 1), flags_11, finalizer_8, userdata_8));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_spanalloc0_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_9 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_9 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_uint8__V__arr0_ptr data = ((nelua_hashmapnode_uint8__V__arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 40), NELUA_NIL, finalizer_9, userdata_9));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_uint8__V__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_uint8__V__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_uint8__V__){0};
}
nelua_span_hashmapnode_string__V__ nelua_GCAllocator_spanalloc0_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_10 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_10 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__V__arr0_ptr data = ((nelua_hashmapnode_string__V__arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 48), NELUA_NIL, finalizer_10, userdata_10));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__V__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__V__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__V__){0};
}
nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_spanalloc0_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_11 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_11 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__V__1_arr0_ptr data = ((nelua_hashmapnode_string__V__1_arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 48), NELUA_NIL, finalizer_11, userdata_11));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__V__1_arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__V___1){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__V___1){0};
}
nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_spanalloc0_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_12 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_12 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__V__2_arr0_ptr data = ((nelua_hashmapnode_string__V__2_arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 48), NELUA_NIL, finalizer_12, userdata_12));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__V__2_arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__V___2){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__V___2){0};
}
nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_spanalloc0_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_13 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_13 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__uint32__arr0_ptr data = ((nelua_hashmapnode_string__uint32__arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 32), NELUA_NIL, finalizer_13, userdata_13));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__uint32__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__uint32__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__uint32__){0};
}
void nelua_assert_line_62(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_sequenceimpl_string__ptr nelua_GCAllocator_new_1(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_sequenceimpl_string__ptr ptr;
  ptr = ((nelua_sequenceimpl_string__ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_62((ptr != ((nelua_sequenceimpl_string__ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_63(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:782:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_FStream_ptr ptr;
  ptr = ((nelua_FStream_ptr)nelua_GCAllocator_alloc_2((&nelua_gc_allocator), 16U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_63((ptr != ((nelua_FStream_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  nelua_memory_copy((void*)ptr, (void*)(&what), 16U);
  return ptr;
}
void nelua_assert_line_64(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_sequenceimpl_uint8__ptr nelua_GCAllocator_new_3(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_sequenceimpl_uint8__ptr ptr;
  ptr = ((nelua_sequenceimpl_uint8__ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_64((ptr != ((nelua_sequenceimpl_uint8__ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_65(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_sequenceimpl_uint64__ptr nelua_GCAllocator_new_4(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_sequenceimpl_uint64__ptr ptr;
  ptr = ((nelua_sequenceimpl_uint64__ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_65((ptr != ((nelua_sequenceimpl_uint64__ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_66(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_sequenceimpl_elf64Shdr__ptr nelua_GCAllocator_new_5(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_sequenceimpl_elf64Shdr__ptr ptr;
  ptr = ((nelua_sequenceimpl_elf64Shdr__ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_66((ptr != ((nelua_sequenceimpl_elf64Shdr__ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_67(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_sequenceimpl_elf64Sym__ptr nelua_GCAllocator_new_6(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_sequenceimpl_elf64Sym__ptr ptr;
  ptr = ((nelua_sequenceimpl_elf64Sym__ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_67((ptr != ((nelua_sequenceimpl_elf64Sym__ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GCAllocator_alloc_1(self, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GCAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GCAllocator_spanrealloc_2(nelua_GCAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_7(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint64_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_uint64_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint64_arr0_ptr p = ((nluint64_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint64_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_elf64Shdr_ nelua_GCAllocator_spanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_elf64Shdr_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_4(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  elf_elf64Shdr_arr0_ptr p = ((elf_elf64Shdr_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 64), (s.size * 64)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((elf_elf64Shdr_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_elf64Sym_ nelua_GCAllocator_spanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_elf64Sym_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_5(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  elf_elf64Sym_arr0_ptr p = ((elf_elf64Sym_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 24), (s.size * 24)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((elf_elf64Sym_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_string_ nelua_GCAllocator_xspanrealloc_2(nelua_GCAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint64_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_uint64_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_elf64Shdr_ nelua_GCAllocator_xspanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_elf64Shdr_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_5(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_elf64Sym_ nelua_GCAllocator_xspanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_elf64Sym_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_6(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_spanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_uint8__V__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_2(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_uint8__V__arr0_ptr p = ((nelua_hashmapnode_uint8__V__arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 40), (s.size * 40)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_uint8__V__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__V__ nelua_GCAllocator_spanrealloc0_3(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_3(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__V__arr0_ptr p = ((nelua_hashmapnode_string__V__arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 48), (s.size * 48)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__V__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_spanrealloc0_4(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___1 s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_4(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__V__1_arr0_ptr p = ((nelua_hashmapnode_string__V__1_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 48), (s.size * 48)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__V__1_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_spanrealloc0_5(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___2 s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_5(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__V__2_arr0_ptr p = ((nelua_hashmapnode_string__V__2_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 48), (s.size * 48)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__V__2_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_spanrealloc0_6(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint32__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_6(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__uint32__arr0_ptr p = ((nelua_hashmapnode_string__uint32__arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__uint32__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_uint8__V__ nelua_GCAllocator_xspanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_uint8__V__ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_string__V__ nelua_GCAllocator_xspanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V__ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_string__V___1 nelua_GCAllocator_xspanrealloc0_3(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___1 s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_string__V___2 nelua_GCAllocator_xspanrealloc0_4(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__V___2 s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_5(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_string__uint32__ nelua_GCAllocator_xspanrealloc0_5(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint32__ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_6(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
bool nelua_strchar_1_isalpha(uint8_t c) {
  return ((((uint32_t)c | 32) - 97U) < 26);
}
bool nelua_strchar_1_islower(uint8_t c) {
  return (((uint32_t)c - 97U) < 26);
}
bool nelua_strchar_1_isupper(uint8_t c) {
  return (((uint32_t)c - 65U) < 26);
}
bool nelua_strchar_1_isdigit(uint8_t c) {
  return (((uint32_t)c - 48U) < 10);
}
bool nelua_strchar_1_isxdigit(uint8_t c) {
  return (nelua_strchar_1_isdigit(c) || ((((uint32_t)c | 32) - 97U) < 6));
}
bool nelua_strchar_1_iscntrl(uint8_t c) {
  return (((uint32_t)c < 0x20) || (c == 0x7f));
}
bool nelua_strchar_1_isgraph(uint8_t c) {
  return (((uint32_t)c - 0x21) < 0x5e);
}
bool nelua_strchar_1_isspace(uint8_t c) {
  return ((c == 32U) || (((uint32_t)c - 9U) < 5));
}
bool nelua_strchar_1_isalnum(uint8_t c) {
  return (nelua_strchar_1_isalpha(c) || nelua_strchar_1_isdigit(c));
}
bool nelua_strchar_1_ispunct(uint8_t c) {
  return (nelua_strchar_1_isgraph(c) && (!nelua_strchar_1_isalnum(c)));
}
uint8_t nelua_strchar_1_getbasedigit(uint8_t c) {
  uint8_t d = (c - 48U);
  if((d < 10)) {
    return d;
  }
  d = (c - 97U);
  if((d < 26)) {
    return (d + 10);
  }
  d = (c - 65U);
  if((d < 26)) {
    return (d + 10);
  }
  return 255U;
}
nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base) {
  if((s.size == 0)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uintptr_t pos = 0U;
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos >= s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  bool neg = false;
  if((s.data[pos] == 45U)) {
    pos = (pos + 1);
    neg = true;
  } else if((s.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((base == 0)) {
    base = 10U;
    if(((s.data[pos] == 48U) && ((pos + 1) < s.size))) {
      uint8_t bc = s.data[(pos + 1)];
      if(((bc == 98U) || (bc == 66U))) {
        base = 2U;
        pos = (pos + 2);
      } else if(((bc == 120U) || (bc == 88U))) {
        base = 16U;
        pos = (pos + 2);
      }
    }
  }
  if((!((base >= 2) && (base <= 36)))) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uint64_t n = 0U;
  while((pos < s.size)) {
    uint64_t x = (uint64_t)nelua_strchar_1_getbasedigit(s.data[pos]);
    if((x >= base)) {
      break;
    }
    n = ((n * base) + x);
    pos = (pos + 1);
  }
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos != s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  if(neg) {
    n = (-n);
  }
  return (nlmulret_nlboolean_nlint64){true, (int64_t)n};
}
nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      intptr_t quot = (x / 10);
      intptr_t rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GCAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->data, self->size))))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_assert_line_68(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:150:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(newsize <= self.data.size, 'not enough space in string buffer')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 137, true);
    nelua_abort();
  }
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  nelua_assert_line_68((newsize <= self->data.size), ((nlstring){(uint8_t*)"not enough space in string buffer", 33}));
  self->size = newsize;
}
nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    nelua_stringbuilderT_destroy(self);
    return (nlstring){0};
  }
  uintptr_t size = self->size;
  nelua_span_uint8_ data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->data, (size + 1));
  (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(data, size))) = 0U;
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
  return (nlstring){.data = data.data, .size = size};
}
void nelua_assert_line_69(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:35:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(size > 0, 'attempt to create an empty string')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nelua_assert_line_69((size > 0), ((nlstring){(uint8_t*)"attempt to create an empty string", 33}));
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (size + 1), NELUA_NIL)), .size = size};
  s.data[size] = 0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc((&nelua_gc_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = (nlstring){0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (s.size + 1), NELUA_NIL));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
void nelua_assert_line_70(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:82:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(i >= 1 and (@usize)(i) <= s.size, 'index out of range')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i) {
  intptr_t i_2 = 1;
  if(NELUA_UNLIKELY((s.size == 0))) {
    return 0U;
  }
  if(NELUA_UNLIKELY((i_2 < 0))) {
    i_2 = (intptr_t)((int64_t)(s.size + i_2) + 1);
  }
  nelua_assert_line_70(((i_2 >= 1) && ((uintptr_t)i_2 <= s.size)), ((nlstring){(uint8_t*)"index out of range", 18}));
  return s.data[(i_2 - 1)];
}
nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j) {
  intptr_t size = (intptr_t)s.size;
  if(NELUA_UNLIKELY((size == 0))) {
    return (nlstring){0};
  }
  if(NELUA_UNLIKELY((i < 0))) {
    i = ((size + i) + 1);
  }
  if(NELUA_UNLIKELY((i <= 0))) {
    i = 1;
  }
  if(NELUA_UNLIKELY((j < 0))) {
    j = ((size + j) + 1);
  }
  if(NELUA_UNLIKELY((j > size))) {
    j = size;
  }
  if(NELUA_UNLIKELY(((i == 1) && (j == size)))) {
    return nelua_nlstring_copy(s);
  }
  if(NELUA_UNLIKELY((i > j))) {
    return (nlstring){0};
  }
  uintptr_t subsize = (uintptr_t)((j - i) + 1);
  if(NELUA_UNLIKELY((subsize == 0))) {
    return (nlstring){0};
  }
  nlstring ret = nelua_nlstring_create(subsize);
  nelua_memory_copy((void*)(&ret.data[0]), (void*)(&s.data[(i - 1)]), subsize);
  return ret;
}
nlstring nelua_nlstring_subview_1(nlstring s, intptr_t i, intptr_t j) {
  intptr_t size = (intptr_t)s.size;
  if(NELUA_UNLIKELY((size == 0))) {
    return (nlstring){0};
  }
  if(NELUA_UNLIKELY((i < 0))) {
    i = ((size + i) + 1);
  }
  if(NELUA_UNLIKELY((i <= 0))) {
    i = 1;
  }
  if(NELUA_UNLIKELY((j < 0))) {
    j = ((size + j) + 1);
  }
  if(NELUA_UNLIKELY((j > size))) {
    j = size;
  }
  if(NELUA_UNLIKELY(((i == 1) && (j == size)))) {
    return s;
  }
  if(NELUA_UNLIKELY((i > j))) {
    return (nlstring){0};
  }
  uintptr_t subsize = (uintptr_t)((j - i) + 1);
  if(NELUA_UNLIKELY((subsize == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&s.data[(i - 1)])), .size = subsize};
}
uint8_t nelua_assert_narrow_nlint64_nluint8(int64_t x) {
  if(NELUA_UNLIKELY(x < 0 || x > 0xff)) {
    nelua_panic_cstring("narrow casting from int64 to uint8 failed");
  }
  return (uint8_t)x;
}
nlstring nelua_nlstring_char_1(int64_t __arg1) {
  nlstring s = nelua_nlstring_create(1U);
  s.data[0] = nelua_assert_narrow_nlint64_nluint8(__arg1);
  return s;
}
nlstring nelua_nlstring_char_2(uint8_t __arg1) {
  nlstring s = nelua_nlstring_create(1U);
  s.data[0] = __arg1;
  return s;
}
void nelua_assert_line_71(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:311:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(i >= 1 and i <= s.size, 'index out of range')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 112, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i) {
  nelua_assert_line_71(((i >= 1) && (i <= s.size)), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&s.data[(i - 1)]);
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
nlstring nelua_nlstring___concat_1(nlstring a, nlstring b) {
  if((a.size == 0)) {
    return nelua_nlstring_copy(b);
  } else if((b.size == 0)) {
    return nelua_nlstring_copy(a);
  }
  nlstring s = nelua_nlstring_create((a.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a.data, a.size);
  nelua_memory_copy((void*)(&s.data[a.size]), (void*)b.data, b.size);
  return s;
}
nlstring nelua_nlstring___concat_3(int64_t a, nlstring b) {
  nlstring a_5 = nelua_tostring_3(a);
  if((a_5.size == 0)) {
    nlstring _ret_1 = nelua_nlstring_copy(b);
    { /* defer */
      nelua_nlstring_destroy((&a_5));
    }
    return _ret_1;
  } else if((b.size == 0)) {
    nlstring _ret_2 = nelua_nlstring_copy(a_5);
    { /* defer */
      nelua_nlstring_destroy((&a_5));
    }
    return _ret_2;
  }
  nlstring s = nelua_nlstring_create((a_5.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a_5.data, a_5.size);
  nelua_memory_copy((void*)(&s.data[a_5.size]), (void*)b.data, b.size);
  nlstring _ret_3 = s;
  { /* defer */
    nelua_nlstring_destroy((&a_5));
  }
  return _ret_3;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self) {
  return (self->len == -1);
}
bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self) {
  return (self->len == -2);
}
bool nelua_match_has_pattern_specials(nlstring pattern) {
  for(uintptr_t i = 0U, _end = pattern.size; i < _end; i += 1) {
    switch(pattern.data[i]) {
      case 94U:
      case 36U:
      case 42U:
      case 43U:
      case 63U:
      case 46U:
      case 40U:
      case 91U:
      case 37U:
      case 45U: {
        return true;
      }
    }
  }
  return false;
}
bool nelua_match_has_pattern_anchor(nlstring pattern) {
  return ((pattern.size > 0) && (pattern.data[0] == 94U));
}
nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain) {
  if((!nelua_match_has_pattern_specials(pattern))) {
    plain = false;
  }
  bool anchor = ((!plain) && nelua_match_has_pattern_anchor(pattern));
  return (nelua_StrPatt_1){.source = source, .pattern = pattern, .depth = 32, .plain = plain, .anchor = anchor};
}
intptr_t nelua_assert_bounds_nlisize(intptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self) {
  for(intptr_t i = 0, _end = self->numcaptures; i < _end; i += 1) {
    self->capture[nelua_assert_bounds_nlisize(i, 32)] = (nelua_StrPattCapture){0};
  }
  self->numcaptures = 0;
}
nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i) {
  if(NELUA_UNLIKELY(((i < 0) || (i >= self->numcaptures)))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"invalid capture index", 21}), (nelua_StrPattCapture){0}};
  }
  if(NELUA_UNLIKELY(nelua_StrPattCapture_is_unfinished((&self->capture[nelua_assert_bounds_nlisize(i, 32)])))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"unfinished capture", 18}), (nelua_StrPattCapture){0}};
  }
  nelua_StrPattCapture capture = self->capture[nelua_assert_bounds_nlisize(i, 32)];
  if((!nelua_StrPattCapture_is_position((&self->capture[nelua_assert_bounds_nlisize(i, 32)])))) {
    nlstring capstr = (nlstring){.data = ((nluint8_arr0_ptr)(&self->source.data[self->capture[nelua_assert_bounds_nlisize(i, 32)].init])), .size = (uintptr_t)self->capture[nelua_assert_bounds_nlisize(i, 32)].len};
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, capstr, capture};
  } else {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, ((nlstring){(uint8_t*)"", 0}), capture};
  }
}
bool nelua_match_class(uint8_t c, uint8_t cl) {
  bool res = false;
  switch(cl) {
    case 97U: {
      res = nelua_strchar_1_isalpha(c);
      break;
    }
    case 65U: {
      res = (!nelua_strchar_1_isalpha(c));
      break;
    }
    case 99U: {
      res = nelua_strchar_1_iscntrl(c);
      break;
    }
    case 67U: {
      res = (!nelua_strchar_1_iscntrl(c));
      break;
    }
    case 100U: {
      res = nelua_strchar_1_isdigit(c);
      break;
    }
    case 68U: {
      res = (!nelua_strchar_1_isdigit(c));
      break;
    }
    case 103U: {
      res = nelua_strchar_1_isgraph(c);
      break;
    }
    case 71U: {
      res = (!nelua_strchar_1_isgraph(c));
      break;
    }
    case 108U: {
      res = nelua_strchar_1_islower(c);
      break;
    }
    case 76U: {
      res = (!nelua_strchar_1_islower(c));
      break;
    }
    case 112U: {
      res = nelua_strchar_1_ispunct(c);
      break;
    }
    case 80U: {
      res = (!nelua_strchar_1_ispunct(c));
      break;
    }
    case 115U: {
      res = nelua_strchar_1_isspace(c);
      break;
    }
    case 83U: {
      res = (!nelua_strchar_1_isspace(c));
      break;
    }
    case 117U: {
      res = nelua_strchar_1_isupper(c);
      break;
    }
    case 85U: {
      res = (!nelua_strchar_1_isupper(c));
      break;
    }
    case 119U: {
      res = nelua_strchar_1_isalnum(c);
      break;
    }
    case 87U: {
      res = (!nelua_strchar_1_isalnum(c));
      break;
    }
    case 120U: {
      res = nelua_strchar_1_isxdigit(c);
      break;
    }
    case 88U: {
      res = (!nelua_strchar_1_isxdigit(c));
      break;
    }
    case 122U: {
      res = (c == 0);
      break;
    }
    case 90U: {
      res = (c != 0);
      break;
    }
    default: {
      return (cl == c);
    }
  }
  return res;
}
void nelua_assert_line_72(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:135:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(p ~= #ms.pattern, \"malformed pattern (ends with '%')\")\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 125, true);
    nelua_abort();
  }
}
void nelua_assert_line_73(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:142:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(p ~= #ms.pattern, \"malformed pattern (missing ']')\")\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 127, true);
    nelua_abort();
  }
}
intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1) {
  uint8_t c = ms_1->pattern.data[p_1];
  p_1 = (p_1 + 1);
  switch(c) {
    case 37U: {
      nelua_assert_line_72((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (ends with '%')", 33}));
      p_1 = (p_1 + 1);
      break;
    }
    case 91U: {
      if((ms_1->pattern.data[p_1] == 94U)) {
        p_1 = (p_1 + 1);
      }
      {
        bool _repeat_stop;
        do {
          nelua_assert_line_73((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (missing ']')", 31}));
          c = ms_1->pattern.data[p_1];
          p_1 = (p_1 + 1);
          if(((c == 37U) && (p_1 < nelua_nlstring___len(ms_1->pattern)))) {
            p_1 = (p_1 + 1);
          }
          _repeat_stop = (ms_1->pattern.data[p_1] == 93U);
        } while(!_repeat_stop);
      }
      p_1 = (p_1 + 1);
      break;
    }
  }
  return p_1;
}
bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep) {
  bool sig = true;
  if((ms_2->pattern.data[(p_2 + 1)] == 94U)) {
    sig = false;
    p_2 = (p_2 + 1);
  }
  p_2 = (p_2 + 1);
  while((p_2 < ep)) {
    if((ms_2->pattern.data[p_2] == 37U)) {
      p_2 = (p_2 + 1);
      if(nelua_match_class(c, ms_2->pattern.data[p_2])) {
        return sig;
      }
    } else if(((ms_2->pattern.data[(p_2 + 1)] == 45U) && ((p_2 + 2) < ep))) {
      p_2 = (p_2 + 2);
      if(((ms_2->pattern.data[(p_2 - 2)] <= c) && (c <= ms_2->pattern.data[p_2]))) {
        return sig;
      }
    } else if((ms_2->pattern.data[p_2] == c)) {
      return sig;
    }
    p_2 = (p_2 + 1);
  }
  return (!sig);
}
bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep) {
  if((s_1 >= nelua_nlstring___len(ms_3->source))) {
    return false;
  } else {
    uint8_t c = ms_3->source.data[s_1];
    uint8_t pc = ms_3->pattern.data[p_3];
    switch(pc) {
      case 46U: {
        return true;
      }
      case 37U: {
        return nelua_match_class(c, ms_3->pattern.data[(p_3 + 1)]);
      }
      case 91U: {
        return nelua_match_bracket_class(ms_3, c, p_3, (ep - 1));
      }
      default: {
        return (pc == c);
      }
    }
  }
}
void nelua_assert_line_74(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:196:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(p < #ms.pattern - 1, \"malformed pattern (missing arguments to '%b')\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 139, true);
    nelua_abort();
  }
}
intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4) {
  nelua_assert_line_74((p_4 < (nelua_nlstring___len(ms_4->pattern) - 1)), ((nlstring){(uint8_t*)"malformed pattern (missing arguments to '%b')", 45}));
  if(((s_2 >= nelua_nlstring___len(ms_4->source)) || (ms_4->source.data[s_2] != ms_4->pattern.data[p_4]))) {
    return -1;
  } else {
    uint8_t b = ms_4->pattern.data[p_4];
    uint8_t e = ms_4->pattern.data[(p_4 + 1)];
    intptr_t cont = 1;
    s_2 = (s_2 + 1);
    while((s_2 < nelua_nlstring___len(ms_4->source))) {
      if((ms_4->source.data[s_2] == e)) {
        cont = (cont - 1);
        if((cont == 0)) {
          return (s_2 + 1);
        }
      } else if((ms_4->source.data[s_2] == b)) {
        cont = (cont + 1);
      }
      s_2 = (s_2 + 1);
    }
  }
  return -1;
}
intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep) {
  intptr_t i = 0;
  while(nelua_match_single(ms_5, (s_3 + i), p_5, ep)) {
    i = (i + 1);
  }
  while((i >= 0)) {
    intptr_t res = nelua_StrPatt_1__match(ms_5, (s_3 + i), (ep + 1));
    if((res != -1)) {
      return res;
    } else {
      i = (i - 1);
    }
  }
  return -1;
}
intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep) {
  while(true) {
    intptr_t res = nelua_StrPatt_1__match(ms_6, s_4, (ep + 1));
    if((res != -1)) {
      return res;
    } else if(nelua_match_single(ms_6, s_4, p_6, ep)) {
      s_4 = (s_4 + 1);
    } else {
      break;
    }
  }
  return -1;
}
void nelua_assert_line_75(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:251:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(numcaptures < #ms.capture, \"too many captures\")\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~\033[0m\n", 123, true);
    nelua_abort();
  }
}
intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what) {
  intptr_t numcaptures = ms_7->numcaptures;
  nelua_assert_line_75((numcaptures < 32), ((nlstring){(uint8_t*)"too many captures", 17}));
  ms_7->capture[nelua_assert_bounds_nlisize(numcaptures, 32)].init = s_5;
  ms_7->capture[nelua_assert_bounds_nlisize(numcaptures, 32)].len = what;
  ms_7->numcaptures = (numcaptures + 1);
  intptr_t res = nelua_StrPatt_1__match(ms_7, s_5, p_7);
  if((res == -1)) {
    ms_7->capture[nelua_assert_bounds_nlisize(numcaptures, 32)] = (nelua_StrPattCapture){0};
    ms_7->numcaptures = (ms_7->numcaptures - 1);
  }
  return res;
}
void nelua_assert_line_76(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:271:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(l ~= -1, \"invalid pattern capture\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 93, true);
    nelua_abort();
  }
}
intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8) {
  intptr_t l = -1;
  for(intptr_t numcaptures = (ms_8->numcaptures - 1); numcaptures >= 0; numcaptures += -1) {
    if((ms_8->capture[nelua_assert_bounds_nlisize(numcaptures, 32)].len == -1)) {
      l = numcaptures;
      break;
    }
  }
  nelua_assert_line_76((l != -1), ((nlstring){(uint8_t*)"invalid pattern capture", 23}));
  ms_8->capture[nelua_assert_bounds_nlisize(l, 32)].len = (s_6 - ms_8->capture[nelua_assert_bounds_nlisize(l, 32)].init);
  intptr_t res = nelua_StrPatt_1__match(ms_8, s_6, p_8);
  if((res == -1)) {
    ms_8->capture[nelua_assert_bounds_nlisize(l, 32)].len = -1;
  }
  return res;
}
void nelua_assert_line_77(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:282:42: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(l >= 0 and l < ms.numcaptures and ms.capture[l].len ~= CAP_UNFINISHED, \"invalid capture index\")\n                                         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 215, true);
    nelua_abort();
  }
}
intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l) {
  l = (intptr_t)(l - 49U);
  nelua_assert_line_77((((l >= 0) && (l < ms_9->numcaptures)) && (ms_9->capture[nelua_assert_bounds_nlisize(l, 32)].len != -1)), ((nlstring){(uint8_t*)"invalid capture index", 21}));
  uintptr_t len = (uintptr_t)ms_9->capture[nelua_assert_bounds_nlisize(l, 32)].len;
  if((((uintptr_t)(nelua_nlstring___len(ms_9->source) - s_7) >= len) && (nelua_memory_compare((void*)(&ms_9->source.data[ms_9->capture[nelua_assert_bounds_nlisize(l, 32)].init]), (void*)(&ms_9->source.data[s_7]), len) == 0))) {
    return (intptr_t)(int64_t)(s_7 + len);
  }
  return -1;
}
void nelua_assert_line_78(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:292:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(ms.depth > 0, 'pattern too complex')\n                  \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
void nelua_assert_line_79(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/detail/strpatt.nelua\033[1m:324:35: \033[31m\033[1mruntime error: \033[0m\033[1m", 90, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(ms.pattern.data[p] == '['_b, \"missing '[' after '%f' in pattern\")\n                                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 151, true);
    nelua_abort();
  }
}
intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p) {
  ms->depth = (ms->depth - 1);
  nelua_assert_line_78((ms->depth > 0), ((nlstring){(uint8_t*)"pattern too complex", 19}));
  while((p < nelua_nlstring___len(ms->pattern))) {
    switch(ms->pattern.data[p]) {
      case 40U: {
        if((ms->pattern.data[(p + 1)] == 41U)) {
          s = nelua_match_start_capture(ms, s, (p + 2), -2);
        } else {
          s = nelua_match_start_capture(ms, s, (p + 1), -1);
        }
        goto _breaklabel_1;
      }
      case 41U: {
        s = nelua_match_end_capture(ms, s, (p + 1));
        goto _breaklabel_1;
      }
      case 36U: {
        if(((p + 1) == nelua_nlstring___len(ms->pattern))) {
          if((s != nelua_nlstring___len(ms->source))) {
            s = -1;
          }
          goto _breaklabel_1;
        }
        break;
      }
      case 37U: {
        switch(ms->pattern.data[(p + 1)]) {
          case 98U: {
            s = nelua_match_balance(ms, s, (p + 2));
            if((s != -1)) {
              p = (p + 4);
              continue;
            }
            goto _breaklabel_1;
          }
          case 102U: {
            p = (p + 2);
            nelua_assert_line_79((ms->pattern.data[p] == 91U), ((nlstring){(uint8_t*)"missing '[' after '%f' in pattern", 33}));
            intptr_t ep = nelua_match_class_end(ms, p);
            uint8_t previous = (((s == 0) && (s < nelua_nlstring___len(ms->source))) ? 0x0U : ms->source.data[(s - 1)]);
            uint8_t next_1 = ((s == nelua_nlstring___len(ms->source)) ? 0x0U : ms->source.data[s]);
            if(((!nelua_match_bracket_class(ms, previous, p, (ep - 1))) && nelua_match_bracket_class(ms, next_1, p, (ep - 1)))) {
              p = ep;
              continue;
            }
            s = -1;
            goto _breaklabel_1;
          }
          case 48U:
          case 49U:
          case 50U:
          case 51U:
          case 52U:
          case 53U:
          case 54U:
          case 55U:
          case 56U:
          case 57U: {
            s = nelua_match_capture(ms, s, (intptr_t)ms->pattern.data[(p + 1)]);
            if((s != -1)) {
              p = (p + 2);
              continue;
            }
            goto _breaklabel_1;
          }
        }
        break;
      }
    }
    {
      intptr_t ep = nelua_match_class_end(ms, p);
      uint8_t epc = ms->pattern.data[ep];
      if((!nelua_match_single(ms, s, p, ep))) {
        if((((epc == 42U) || (epc == 63U)) || (epc == 45U))) {
          p = (ep + 1);
          continue;
        } else {
          s = -1;
        }
      } else {
        switch(epc) {
          case 63U: {
            intptr_t res = nelua_StrPatt_1__match(ms, (s + 1), (ep + 1));
            if((res != -1)) {
              s = res;
            } else {
              p = (ep + 1);
              continue;
            }
            break;
          }
          case 43U: {
            s = (s + 1);
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 42U: {
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 45U: {
            s = nelua_match_min_expand(ms, s, p, ep);
            break;
          }
          default: {
            s = (s + 1);
            p = ep;
            continue;
          }
        }
      }
      break;
    }
  }
  _breaklabel_1:;
  ms->depth = (ms->depth + 1);
  return s;
}
nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s) {
  if(((uintptr_t)s > ms->source.size)) {
    return (nlmulret_nlisize_nlisize){s, -1};
  } else if((ms->pattern.size == 0)) {
    return (nlmulret_nlisize_nlisize){s, s};
  } else if(ms->plain) {
    void* found = nelua_memory_find((void*)(&ms->source.data[s]), (ms->source.size - (uintptr_t)s), (void*)(&ms->pattern.data[0]), ms->pattern.size);
    if((!(found != NULL))) {
      return (nlmulret_nlisize_nlisize){s, -1};
    } else {
      s = (intptr_t)((uintptr_t)found - (uintptr_t)(&ms->source.data[0]));
      return (nlmulret_nlisize_nlisize){s, (intptr_t)(int64_t)(s + ms->pattern.size)};
    }
  } else {
    intptr_t p = 0;
    if(ms->anchor) {
      p = 1;
    }
    {
      bool _repeat_stop;
      do {
        nelua_StrPatt_1_reset_captures(ms);
        intptr_t e = nelua_StrPatt_1__match(ms, s, p);
        if((e != -1)) {
          return (nlmulret_nlisize_nlisize){s, e};
        }
        s = (s + 1);
        _repeat_stop = ((s > nelua_nlstring___len(ms->source)) || ms->anchor);
      } while(!_repeat_stop);
    }
    return (nlmulret_nlisize_nlisize){s, -1};
  }
}
void nelua_assert_line_80(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:814:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(ok, capstr)\n               \033[1m\033[32m^\033[0m\033[35m~\033[0m\n", 72, true);
    nelua_abort();
  }
}
void nelua_assert_line_81(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:815:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(not capture:is_position(), 'position capture not supported yet')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 148, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nelua_sequence_string_ nelua_string_match_1(nlstring s, nlstring pattern, nlniltype init) {
  intptr_t init_1 = 1;
  nelua_StrPatt_1 ms = nelua_StrPatt_1_create(s, pattern, false);
  nlmulret_nlisize_nlisize _asgnret_1 = nelua_StrPatt_1_match((&ms), (init_1 - 1));
  intptr_t startpos = _asgnret_1.r1;
  intptr_t endpos = _asgnret_1.r2;
  nelua_sequence_string_ captures = (nelua_sequence_string_){0};
  if((endpos != -1)) {
    if((ms.numcaptures > 0)) {
      nelua_sequence_string__resize((&captures), (uintptr_t)ms.numcaptures);
      for(intptr_t i = 0, _end = ms.numcaptures; i < _end; i += 1) {
        nlmulret_nlboolean_nlstring_nelua_StrPattCapture _asgnret_2 = nelua_StrPatt_1_get_capture((&ms), i);
        bool ok = _asgnret_2.r1;
        nlstring capstr = _asgnret_2.r2;
        nelua_StrPattCapture capture = _asgnret_2.r3;
        nelua_assert_line_80(ok, capstr);
        nelua_assert_line_81((!nelua_StrPattCapture_is_position((&capture))), ((nlstring){(uint8_t*)"position capture not supported yet", 34}));
        (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&captures), (uintptr_t)(i + 1)))) = capstr;
      }
      return (nlmulret_nlboolean_nelua_sequence_string_){true, captures};
    } else {
      (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&captures), 1U))) = nelua_nlstring_subview_1(ms.source, (startpos + 1), endpos);
      return (nlmulret_nlboolean_nelua_sequence_string_){true, captures};
    }
  } else {
    return (nlmulret_nlboolean_nelua_sequence_string_){false, captures};
  }
}
nlmulret_nlboolean_nelua_sequence_string_ nelua_nlstring_match_1(nlstring s, nlstring pattern, nlniltype init) {
  nlmulret_nlboolean_nelua_sequence_string_ _asgnret_1 = nelua_string_match_1(s, pattern, NELUA_NIL);
  bool ok = _asgnret_1.r1;
  nelua_sequence_string_ seq = _asgnret_1.r2;
  for(uintptr_t i = 1U, _end = (uintptr_t)nelua_sequence_string____len((&seq)); i <= _end; i += 1) {
    (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&seq), i))) = nelua_nlstring_copy((*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&seq), i))));
  }
  return (nlmulret_nlboolean_nelua_sequence_string_){ok, seq};
}
nlstring nelua_tostring_3(int64_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), (intptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
void nelua_assert_line_82(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:1002:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ok, 'malformed integer')\n           \033[1m\033[32m^\033[0m\033[35m~\033[0m\n", 77, true);
    nelua_abort();
  }
}
int64_t nelua_tointeger_1(nlstring x, nlniltype base) {
  nlmulret_nlboolean_nlint64 _asgnret_1 = nelua_strconv_1_str2int(x, 0U);
  bool ok = _asgnret_1.r1;
  int64_t i = _asgnret_1.r2;
  nelua_assert_line_82(ok, ((nlstring){(uint8_t*)"malformed integer", 17}));
  return i;
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
nelua_sequence_string__1 nelua_require_arg(nlniltype modname) {
  if((nelua_argc > 0)) {
    uintptr_t narg = (uintptr_t)(nelua_argc - 1);
    nelua_sequence_string__1_reserve((&nelua_arg), narg);
    for(uintptr_t i = 0U, _end = narg; i <= _end; i += 1) {
      (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), i))) = nelua_cstring2string(nelua_argv[i]);
    }
  }
  return nelua_arg;
}
void nelua_print_1(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputs("\n", stdout);
  fflush(stdout);
}
nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_3W1frj6TeMnyakpkp closef) {
  return (nelua_filestream){.fs = nelua_GCAllocator_new_2((&nelua_gc_allocator), (nelua_FStream){.fp = fp, .closef = closef}, NELUA_NIL, NELUA_NIL)};
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
char* nelua_assert_string2cstring(nlstring s) {
  if(s.size == 0) {
    return (char*)"";
  }
  if(NELUA_UNLIKELY(s.data[s.size]) != 0) {
    nelua_panic_cstring("attempt to convert a non null terminated string to cstring");
  }
  return (char*)s.data;
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlniltype mode) {
  nlstring mode_1 = ((nlstring){(uint8_t*)"r", 1});
  FILE_ptr fp = fopen(nelua_assert_string2cstring(filename), nelua_assert_string2cstring(mode_1));
  if((!(fp != NULL))) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nelua_filestream_nlstring_nlint64){(nelua_filestream){0}, _ret_1.r1, _ret_1.r2};
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  _mulret_1.r1 = nelua_filestream__fromfp(fp, fclose);
  _mulret_1.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_1.r3 = 0;
  return _mulret_1;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self) {
  nelua_FStream_ptr fs = self->fs;
  if(((!(fs != NULL)) || (!(fs->fp != NULL)))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((((fs->fp == stdout) || (fs->fp == stderr)) || (fs->fp == stdin))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"cannot close standard file", 26}), -1};
  }
  int res = 0;
  if((fs->closef != NULL)) {
    res = fs->closef(fs->fp);
  }
  self->fs->fp = ((FILE_ptr)NULL);
  self->fs->closef = (function_5EHewGogcy7PehX8r)NULL;
  if((res != 0)) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_1(nelua_filestream_ptr self, nlstring whence, nlniltype offset) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlint64_nlstring_nlint64){-1, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  int64_t offset_1 = 0;
  int op = 0;
  if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"set", 3}))) {
    op = SEEK_SET;
  } else if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"end", 3}))) {
    op = SEEK_END;
  } else if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"cur", 3}))) {
    op = SEEK_CUR;
  } else {
    return (nlmulret_nlint64_nlstring_nlint64){-1, ((nlstring){(uint8_t*)"invalid whence", 14}), -1};
  }
  int64_t len = 0;
  nlstring errmsg = (nlstring){0};
  int64_t status = 0;
  if((fseek(fp, (long)offset_1, op) == 0)) {
    len = (int64_t)ftell(fp);
  } else {
    len = -1;
    nlmulret_nlstring_nlint64 _asgnret_1 = nelua_geterrno();
    errmsg = _asgnret_1.r1;
    status = _asgnret_1.r2;
  }
  return (nlmulret_nlint64_nlstring_nlint64){len, errmsg, status};
}
nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_2(nelua_filestream_ptr self, nlniltype whence, nlniltype offset) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlint64_nlstring_nlint64){-1, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  int64_t len = (int64_t)ftell(fp);
  return (nlmulret_nlint64_nlstring_nlint64){len, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlint64_nlstring_nlint64 nelua_filestream_seek_3(nelua_filestream_ptr self, nlstring whence, int64_t offset) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlint64_nlstring_nlint64){-1, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  int op = 0;
  if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"set", 3}))) {
    op = SEEK_SET;
  } else if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"end", 3}))) {
    op = SEEK_END;
  } else if(nelua_nlstring___eq(whence, ((nlstring){(uint8_t*)"cur", 3}))) {
    op = SEEK_CUR;
  } else {
    return (nlmulret_nlint64_nlstring_nlint64){-1, ((nlstring){(uint8_t*)"invalid whence", 14}), -1};
  }
  int64_t len = 0;
  nlstring errmsg = (nlstring){0};
  int64_t status = 0;
  if((fseek(fp, (long)offset, op) == 0)) {
    len = (int64_t)ftell(fp);
  } else {
    len = -1;
    nlmulret_nlstring_nlint64 _asgnret_1 = nelua_geterrno();
    errmsg = _asgnret_1.r1;
    status = _asgnret_1.r2;
  }
  return (nlmulret_nlint64_nlstring_nlint64){len, errmsg, status};
}
nlmulret_nlboolean_nlstring nelua_readchars(nelua_stringbuilderT_ptr sb, FILE_ptr fp, uintptr_t n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(sb, n);
  if(nelua_span_uint8__empty(p)) {
    return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
  }
  size_t nr = fread((void*)p.data, 1U, (size_t)n, fp);
  nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
  return (nlmulret_nlboolean_nlstring){(nr > 0), (nlstring){0}};
}
nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, int64_t fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlstring_nlstring_nlint64){(nlstring){0}, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  bool success = false;
  nlstring errmsg = (nlstring){0};
  clearerr(fp);
  nlmulret_nlboolean_nlstring _asgnret_1 = nelua_readchars((&sb), fp, nelua_assert_narrow_nlint64_nlusize(fmt));
  success = _asgnret_1.r1;
  errmsg = _asgnret_1.r2;
  int64_t status = 0;
  if((ferror(fp) != 0)) {
    success = false;
    nlmulret_nlstring_nlint64 _asgnret_2 = nelua_geterrno();
    errmsg = _asgnret_2.r1;
    status = _asgnret_2.r2;
  }
  nlstring s = (nlstring){0};
  if(success) {
    s = nelua_stringbuilderT_promote((&sb));
  } else {
    if((nelua_nlstring___len(errmsg) == 0)) {
      errmsg = ((nlstring){(uint8_t*)"eof", 3});
      status = (int64_t)EOF;
    } else if((status == 0)) {
      status = -1;
    }
    nelua_stringbuilderT_destroy((&sb));
  }
  return (nlmulret_nlstring_nlstring_nlint64){s, errmsg, status};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
bool nelua_filestream_isopen(nelua_filestream_ptr self) {
  return ((self->fs != ((nelua_FStream_ptr)NULL)) && (self->fs->fp != ((FILE_ptr)NULL)));
}
nlmulret_nlstring_nlint64 nelua_geterrno_1(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlniltype mode) {
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  nlmulret_nelua_filestream_nlstring_nlint64 _ret_1 = nelua_filestream_open_1(filename, NELUA_NIL);
  _mulret_1.r1 = _ret_1.r1;
  _mulret_1.r2 = _ret_1.r2;
  _mulret_1.r3 = _ret_1.r3;
  return _mulret_1;
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_popen_1(nlstring prog, nlniltype mode) {
  nlstring mode_2 = ((nlstring){(uint8_t*)"r", 1});
  char* modecs = nelua_assert_string2cstring(mode_2);
  char* progcs = nelua_assert_string2cstring(prog);
  FILE_ptr fp = NULL;
  function_2BF7i3e13pYtjRHM2 closef = NULL;
#if defined(_WIN32)
  fp = _popen(progcs, modecs);
  closef = _pclose;
#elif _POSIX_VERSION >= 200112L
  fflush(((FILE_ptr)NULL));
  fp = popen(progcs, modecs);
  closef = pclose;
#endif
  if(((!(fp != NULL)) && (!(closef != NULL)))) {
    return (nlmulret_nelua_filestream_nlstring_nlint64){(nelua_filestream){0}, ((nlstring){(uint8_t*)"unsupported", 11}), -1};
  } else if((!(fp != NULL))) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno_1();
    return (nlmulret_nelua_filestream_nlstring_nlint64){(nelua_filestream){0}, _ret_1.r1, _ret_1.r2};
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  _mulret_1.r1 = nelua_filestream__fromfp(fp, closef);
  _mulret_1.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_1.r3 = 0;
  return _mulret_1;
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stderrfs = (nelua_FStream){.fp = stderr};
  nelua_io_stderr = (nelua_filestream){.fs = (&nelua_stderrfs)};
  return NELUA_NIL;
}
int nelua_assert_narrow_nlint64_nlcint(int64_t x) {
  if(NELUA_UNLIKELY(x > 0x7fffffff || x < (-2147483647-1))) {
    nelua_panic_cstring("narrow casting from int64 to cint failed");
  }
  return (int)x;
}
void nelua_os_exit_1(int64_t code) {
  exit(nelua_assert_narrow_nlint64_nlcint(code));
}
int64_t common_getProgramSize(void) {
  return (int64_t)nelua_sequence_uint8____len((&common_program));
}
void common_rasmError_1(nlstring str, nlniltype code) {
  nelua_filestream_write_1((&nelua_io_stderr), nelua_nlstring___concat_1(common_filein, nelua_nlstring___concat_1(((nlstring){(uint8_t*)":", 1}), nelua_nlstring___concat_3(common_curLine, nelua_nlstring___concat_1(((nlstring){(uint8_t*)": Error ", 8}), nelua_nlstring___concat_1(str, ((nlstring){(uint8_t*)"\n", 1})))))));
  nelua_os_exit_1(1);
}
void common_rasmError_2(nlstring str, uint8_t code) {
  nelua_filestream_write_1((&nelua_io_stderr), nelua_nlstring___concat_1(common_filein, nelua_nlstring___concat_1(((nlstring){(uint8_t*)":", 1}), nelua_nlstring___concat_3(common_curLine, nelua_nlstring___concat_1(((nlstring){(uint8_t*)": Error ", 8}), nelua_nlstring___concat_1(str, ((nlstring){(uint8_t*)"\n", 1})))))));
  nelua_os_exit_1((int64_t)code);
}
nlstring common_parseString(nlstring str) {
  bool escape = false;
  nlstring retStr = ((nlstring){(uint8_t*)"", 0});
  {
    nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64 _asgnret_1 = nelua_ipairs_1((&str));
    function_3LPNAr7nduHuY3ETf __fornext = _asgnret_1.r1;
    nlstring_ptr __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint8 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint8_t char_ = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        if(escape) {
          switch(char_) {
            case 34: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\"", 1}));
              break;
            }
            case 39: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"'", 1}));
              break;
            }
            case 92: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\\", 1}));
              break;
            }
            case 97: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\a", 1}));
              break;
            }
            case 98: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\b", 1}));
              break;
            }
            case 101: {
              retStr = nelua_nlstring___concat_1(retStr, nelua_nlstring_char_1(0x1b));
              break;
            }
            case 110: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\n", 1}));
              break;
            }
            case 114: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\r", 1}));
              break;
            }
            case 116: {
              retStr = nelua_nlstring___concat_1(retStr, ((nlstring){(uint8_t*)"\t", 1}));
              break;
            }
            default: {
              common_rasmError_1(((nlstring){(uint8_t*)"", 0}), NELUA_NIL);
              break;
            }
          }
          escape = false;
        } else {
          switch(char_) {
            case 92: {
              escape = true;
              break;
            }
            case 39: {
              NELUA_FALLTHROUGH(); /* fallthrough */
            }
            case 34: {
              return retStr;
            }
            default: {
              retStr = nelua_nlstring___concat_1(retStr, nelua_nlstring_char_2(char_));
              break;
            }
          }
        }
      }
    }
  }
  return retStr;
}
bool nelua_eq_nlisize_nluint64(intptr_t a, uint64_t b) {
  return (uint64_t)a == (uint64_t)b && a >= 0;
}
void argHandling_handleOpt(uint8_t char_, uint64_t i) {
  switch((*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), char_))).type) {
    case 0: {
      (*(bool*)nelua_assert_deref((nlboolean_ptr)(*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), char_))).execArgsP)) = (!(*(bool*)nelua_assert_deref((nlboolean_ptr)(*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), char_))).execArgsP)));
      break;
    }
    case 1: {
      if(nelua_eq_nlisize_nluint64(nelua_sequence_string__1___len((&nelua_arg)), i)) {
        nelua_print_1(((nlstring){(uint8_t*)"Error: No argument for option", 29}));
        nelua_print_1(main_usageStr);
        nelua_os_exit_1(2);
      } else {
        argHandling_fileout = (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1))));
        argHandling_skipArg = true;
      }
      break;
    }
  }
}
uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to uint64 failed");
  }
  return (uint64_t)x;
}
void nelua_require_argHandling(nlniltype modname) {
  argHandling_execPath = (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 0U)));
  (*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), nelua_nlstring_byte_1(((nlstring){(uint8_t*)"d", 1}), NELUA_NIL)))) = (nelua_V_2){0, (void*)(&argHandling_execArgs.dump)};
  (*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), nelua_nlstring_byte_1(((nlstring){(uint8_t*)"s", 1}), NELUA_NIL)))) = (nelua_V_2){0, (void*)(&argHandling_execArgs.strip)};
  (*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), nelua_nlstring_byte_1(((nlstring){(uint8_t*)"3", 1}), NELUA_NIL)))) = (nelua_V_2){0, (void*)(&argHandling_execArgs.bit32)};
  (*(nelua_V_2*)nelua_assert_deref(nelua_hashmap_uint8__V____atindex((&argHandling_opt), nelua_nlstring_byte_1(((nlstring){(uint8_t*)"o", 1}), NELUA_NIL)))) = (nelua_V_2){1, (void*)0};
  {
    nlmulret_function_eUm9hA9ggP1BUyYv_nelua_sequence_string__1_nlint64 _asgnret_1 = nelua_ipairs_2(nelua_arg);
    function_eUm9hA9ggP1BUyYv __fornext = _asgnret_1.r1;
    nelua_sequence_string__1 __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nlstring _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t i = _asgnret_2.r2;
      nlstring a = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = i;
      {
        if(argHandling_skipArg) {
          if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
            nelua_print_1(((nlstring){(uint8_t*)"Error: No filein", 16}));
            nelua_print_1(main_usageStr);
            nelua_os_exit_1(2);
          }
          argHandling_skipArg = false;
          continue;
        }
        if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
          common_filein = a;
          break;
        }
        {
          nlmulret_function_3LPNAr7nduHuY3ETf_nlstring_ptr_nlint64 _asgnret_3 = nelua_ipairs_1((&(*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i))))));
          function_3LPNAr7nduHuY3ETf __fornext_1 = _asgnret_3.r1;
          nlstring_ptr __forstate_1 = _asgnret_3.r2;
          int64_t __fornextit_1 = _asgnret_3.r3;
          while(true) {
            nlmulret_nlboolean_nlint64_nluint8 _asgnret_4 = __fornext_1(__forstate_1, __fornextit_1);
            bool __forcont_1 = _asgnret_4.r1;
            int64_t _ = _asgnret_4.r2;
            uint8_t v = _asgnret_4.r3;
            if((!__forcont_1)) {
              break;
            }
            __fornextit_1 = _;
            {
              if(nelua_nlstring___eq(nelua_nlstring_char_2(v), ((nlstring){(uint8_t*)"-", 1}))) {
                continue;
              }
              if((!nelua_hashmap_uint8__V__has((&argHandling_opt), v))) {
                nelua_print_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Error: \"", 8}), ({
                  nlstring _tmp1 = nelua_nlstring_char_2(v);
                  nlstring _tmp2 = nelua_nlstring___concat_1(((nlstring){(uint8_t*)"\"", 1}), ((nlstring){(uint8_t*)" No such option", 15}));
                  nelua_nlstring___concat_1(_tmp1, _tmp2);
                })));
                nelua_print_1(main_usageStr);
                nelua_os_exit_1(2);
              }
              argHandling_handleOpt(v, nelua_assert_narrow_nlint64_nluint64(i));
            }
          }
        }
      }
    }
  }
  argHandling_fileout = (nelua_nlstring___eq(argHandling_fileout, ((nlstring){(uint8_t*)"", 0})) ? ((nlstring){(uint8_t*)"./a.out", 7}) : argHandling_fileout);
}
syntax_syntax syntax_Parse(nelua_filestream file) {
  if((syntax_fileLen == 0)) {
    nelua_filestream_seek_1((&file), ((nlstring){(uint8_t*)"end", 3}), NELUA_NIL);
    syntax_fileLen = nelua_filestream_seek_2((&file), NELUA_NIL, NELUA_NIL).r1;
    nelua_filestream_seek_1((&file), ((nlstring){(uint8_t*)"set", 3}), NELUA_NIL);
  }
  syntax_syntax ret = (syntax_syntax){0};
  nlstring c = nelua_filestream_read_1((&file), 1).r1;
  if(syntax_eof) {
    ret.str = ((nlstring){(uint8_t*)"EOF", 3});
    ret.type = 255U;
    syntax_eof = false;
    return ret;
  }
  if((nelua_filestream_seek_2((&file), NELUA_NIL, NELUA_NIL).r1 >= syntax_fileLen)) {
    syntax_eof = true;
    syntax_fileLen = 0;
  }
  if((!nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"\"", 1})))) {
    ret.str = c;
  }
  if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)";", 1}), NELUA_NIL).r1) {
    ret.type = 0U;
    c = nelua_filestream_read_1((&file), 1).r1;
    while(((nelua_nlstring___len(c) != 0) && (!nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"\n", 1}))))) {
      ret.str = nelua_nlstring___concat_1(ret.str, c);
      c = nelua_filestream_read_1((&file), 1).r1;
    }
    nelua_filestream_seek_3((&file), ((nlstring){(uint8_t*)"cur", 3}), -1);
  } else if(nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"\n", 1}))) {
    ret.type = 1U;
    common_curLine = (common_curLine + 1);
  } else if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%s", 2}), NELUA_NIL).r1) {
    ret.type = 2U;
    c = nelua_filestream_read_1((&file), 1).r1;
    while(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%s^\n", 4}), NELUA_NIL).r1) {
      ret.str = nelua_nlstring___concat_1(ret.str, c);
      c = nelua_filestream_read_1((&file), 1).r1;
    }
    nelua_filestream_seek_3((&file), ((nlstring){(uint8_t*)"cur", 3}), -1);
  } else if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"[:=%+%-%*%%#,]", 14}), NELUA_NIL).r1) {
    ret.type = 3U;
    if(nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"-", 1}))) {
      c = nelua_filestream_read_1((&file), 1).r1;
      if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%d", 2}), NELUA_NIL).r1) {
        ret.type = 5U;
        ret.str = nelua_nlstring___concat_1(ret.str, c);
        c = nelua_filestream_read_1((&file), 1).r1;
        while(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%d", 2}), NELUA_NIL).r1) {
          ret.str = nelua_nlstring___concat_1(ret.str, c);
          c = nelua_filestream_read_1((&file), 1).r1;
        }
        nelua_filestream_seek_3((&file), ((nlstring){(uint8_t*)"cur", 3}), -1);
      }
    }
  } else if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"['\"]", 4}), NELUA_NIL).r1) {
    ret.type = 4U;
    c = nelua_filestream_read_1((&file), 1).r1;
    while((!nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"['\"]", 4}), NELUA_NIL).r1)) {
      ret.str = nelua_nlstring___concat_1(ret.str, c);
      if(nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"\\", 1}))) {
        c = nelua_filestream_read_1((&file), 1).r1;
        ret.str = nelua_nlstring___concat_1(ret.str, c);
      }
      c = nelua_filestream_read_1((&file), 1).r1;
    }
  } else if((nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"(", 1})) || nelua_nlstring___eq(c, ((nlstring){(uint8_t*)")", 1})))) {
    ret.type = 7U;
  } else if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%d", 2}), NELUA_NIL).r1) {
    ret.type = 5U;
    c = nelua_filestream_read_1((&file), 1).r1;
    if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%d", 2}), NELUA_NIL).r1) {
      while(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"%d", 2}), NELUA_NIL).r1) {
        ret.str = nelua_nlstring___concat_1(ret.str, c);
        c = nelua_filestream_read_1((&file), 1).r1;
      }
    } else if(nelua_nlstring___eq(c, ((nlstring){(uint8_t*)"x", 1}))) {
      ret.str = nelua_nlstring___concat_1(ret.str, c);
      c = nelua_filestream_read_1((&file), 1).r1;
      while(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"[%da-fA-F]", 10}), NELUA_NIL).r1) {
        ret.str = nelua_nlstring___concat_1(ret.str, c);
        c = nelua_filestream_read_1((&file), 1).r1;
      }
    }
    nelua_filestream_seek_3((&file), ((nlstring){(uint8_t*)"cur", 3}), -1);
  } else if(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"[%w_]", 5}), NELUA_NIL).r1) {
    ret.type = 6U;
    c = nelua_filestream_read_1((&file), 1).r1;
    while(nelua_nlstring_match_1(c, ((nlstring){(uint8_t*)"[%w_]", 5}), NELUA_NIL).r1) {
      ret.str = nelua_nlstring___concat_1(ret.str, c);
      c = nelua_filestream_read_1((&file), 1).r1;
    }
    nelua_filestream_seek_3((&file), ((nlstring){(uint8_t*)"cur", 3}), -1);
  }
  if(false) {
    common_rasmError_2(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Unknown Syntax ", 15}), c), 1U);
  }
  if((nelua_nlstring_byte_1(c, NELUA_NIL) == 0)) {
    syntax_eof = true;
    syntax_fileLen = 0;
  }
  return ret;
}
void nelua_require_label(nlniltype modname) {
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"zero", 4})))) = (nelua_V_3){0U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"ra", 2})))) = (nelua_V_3){1U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"sp", 2})))) = (nelua_V_3){2U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"gp", 2})))) = (nelua_V_3){3U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"tp", 2})))) = (nelua_V_3){4U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t0", 2})))) = (nelua_V_3){5U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t1", 2})))) = (nelua_V_3){6U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t2", 2})))) = (nelua_V_3){7U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"fp", 2})))) = (nelua_V_3){8U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s0", 2})))) = (nelua_V_3){8U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s1", 2})))) = (nelua_V_3){9U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a0", 2})))) = (nelua_V_3){10U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a1", 2})))) = (nelua_V_3){11U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a2", 2})))) = (nelua_V_3){12U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a3", 2})))) = (nelua_V_3){13U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a4", 2})))) = (nelua_V_3){14U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a5", 2})))) = (nelua_V_3){15U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a6", 2})))) = (nelua_V_3){16U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"a7", 2})))) = (nelua_V_3){17U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s2", 2})))) = (nelua_V_3){18U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s3", 2})))) = (nelua_V_3){19U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s4", 2})))) = (nelua_V_3){20U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s5", 2})))) = (nelua_V_3){21U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s6", 2})))) = (nelua_V_3){22U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s7", 2})))) = (nelua_V_3){23U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s8", 2})))) = (nelua_V_3){24U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s9", 2})))) = (nelua_V_3){25U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s10", 3})))) = (nelua_V_3){26U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"s11", 3})))) = (nelua_V_3){27U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t3", 2})))) = (nelua_V_3){28U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t4", 2})))) = (nelua_V_3){29U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t5", 2})))) = (nelua_V_3){30U, -1};
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"t6", 2})))) = (nelua_V_3){31U, -1};
}
uint64_t instr_getArg(nlstring str) {
  if(nelua_nlstring_match_1(str, ((nlstring){(uint8_t*)"^-?%d*$", 7}), NELUA_NIL).r1) {
    return (uint64_t)nelua_tointeger_1(str, NELUA_NIL);
  } else if(nelua_nlstring_match_1(str, ((nlstring){(uint8_t*)"^0x?[%da-fA-F]*$", 16}), NELUA_NIL).r1) {
    return (uint64_t)nelua_tointeger_1(str, NELUA_NIL);
  } else if(nelua_hashmap_string__V__has((&label_labels), str)) {
    if(((*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), str))).length == -1)) {
      return (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), str))).value;
    } else {
      return (uint64_t)(int64_t)((*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), str))).value - common_getProgramSize());
    }
  } else if(nelua_nlstring_match_1(str, ((nlstring){(uint8_t*)"^%%", 3}), NELUA_NIL).r1) {
    nlstring label = nelua_nlstring_sub_1(str, 2, nelua_nlstring___len(str));
    if(nelua_hashmap_string__V__has((&label_labels), label)) {
      return (uint64_t)(*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), label))).length;
    }
  }
  return 0U;
}
uint32_t nelua_assert_narrow_nluint64_nluint32(uint64_t x) {
  if(NELUA_UNLIKELY(x > 0xffffffffULL)) {
    nelua_panic_cstring("narrow casting from uint64 to uint32 failed");
  }
  return (uint32_t)x;
}
nluint8_arr4 instr_getInstr(nlstring mnemonic, nelua_sequence_uint64_ args) {
  if((!nelua_hashmap_string__V__1_has((&instr_instruction), mnemonic))) {
    nelua_print_1(((nlstring){(uint8_t*)"Error: no such mnemonic", 23}));
    nelua_os_exit_1(1);
  }
  nelua_V_4 curInstr = (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), mnemonic)));
  uint32_t instr = (uint32_t)curInstr.opcode;
  switch(curInstr.type) {
    case 0: {
      instr = nelua_assert_narrow_nluint64_nluint32((instr | ((uint64_t)curInstr.func7 << 20)));
      break;
    }
    case 2: {
      NELUA_FALLTHROUGH(); /* fallthrough */
    }
    case 1: {
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))) << 7));
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) << 15));
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) << 20));
      instr = (instr | ((uint32_t)curInstr.func3 << 12));
      instr = (instr | ((uint32_t)curInstr.func7 << 25));
      break;
    }
    case 3: {
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))) << 15));
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) << 20));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) & 0x1f) << 7));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) >> 5) << 25));
      instr = (instr | ((uint32_t)curInstr.func3 << 12));
      break;
    }
    case 4: {
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))) << 15));
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) << 20));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) & 0x1e) << 7));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) & 0x7e0) << 20));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) & 0x800) >> 4));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U))) & 0x1000) << 19));
      instr = (instr | ((uint32_t)curInstr.func3 << 12));
      break;
    }
    case 5: {
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))) << 7));
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) << 12));
      break;
    }
    case 6: {
      instr = (instr | (uint32_t)((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))) << 7));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) & 0x7fe) << 20));
      instr = (instr | (uint32_t)((((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 11) & 1) << 20));
      instr = (instr | (uint32_t)((((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 12) & 0xff) << 12));
      instr = (instr | (uint32_t)(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 20) << 31));
      break;
    }
  }
  return (nluint8_arr4){{(uint8_t)instr, (uint8_t)(instr >> 8), (uint8_t)(instr >> 16), (uint8_t)(instr >> 24)}};
}
void nelua_require_base(nlniltype modname) {
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lb", 2})))) = (nelua_V_4){1, 0x3U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lh", 2})))) = (nelua_V_4){1, 0x3U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lw", 2})))) = (nelua_V_4){1, 0x3U, 2U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"ld", 2})))) = (nelua_V_4){1, 0x3U, 3U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lbu", 3})))) = (nelua_V_4){1, 0x3U, 4U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lhu", 3})))) = (nelua_V_4){1, 0x3U, 5U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lwu", 3})))) = (nelua_V_4){1, 0x3U, 6U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"fence", 5})))) = (nelua_V_4){1, 0xfU, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"fence.i", 7})))) = (nelua_V_4){1, 0xfU, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"addi", 4})))) = (nelua_V_4){1, 0x13U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"slli", 4})))) = (nelua_V_4){1, 0x13U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"slti", 4})))) = (nelua_V_4){1, 0x13U, 2U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sltiu", 5})))) = (nelua_V_4){1, 0x13U, 3U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"xori", 4})))) = (nelua_V_4){1, 0x13U, 4U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"srli", 4})))) = (nelua_V_4){1, 0x13U, 5U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"srai", 4})))) = (nelua_V_4){1, 0x13U, 5U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"ori", 3})))) = (nelua_V_4){1, 0x13U, 6U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"andi", 4})))) = (nelua_V_4){1, 0x13U, 7U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"addiw", 5})))) = (nelua_V_4){1, 0x1bU, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"slliw", 5})))) = (nelua_V_4){1, 0x1bU, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"srliw", 5})))) = (nelua_V_4){1, 0x1bU, 5U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sraiw", 5})))) = (nelua_V_4){1, 0x1bU, 5U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"jalr", 4})))) = (nelua_V_4){1, 0x67U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrw", 5})))) = (nelua_V_4){1, 0x73U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrs", 5})))) = (nelua_V_4){1, 0x73U, 2U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrc", 5})))) = (nelua_V_4){1, 0x73U, 3U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrwi", 6})))) = (nelua_V_4){1, 0x73U, 5U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrsi", 6})))) = (nelua_V_4){1, 0x73U, 6U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"csrrci", 6})))) = (nelua_V_4){1, 0x73U, 7U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"add", 3})))) = (nelua_V_4){2, 0x33U, 0U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sub", 3})))) = (nelua_V_4){2, 0x33U, 0U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sll", 3})))) = (nelua_V_4){2, 0x33U, 1U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"slt", 3})))) = (nelua_V_4){2, 0x33U, 2U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sltu", 4})))) = (nelua_V_4){2, 0x33U, 3U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"xor", 3})))) = (nelua_V_4){2, 0x33U, 4U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"srl", 3})))) = (nelua_V_4){2, 0x33U, 5U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sra", 3})))) = (nelua_V_4){2, 0x33U, 5U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"or", 2})))) = (nelua_V_4){2, 0x33U, 6U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"and", 3})))) = (nelua_V_4){2, 0x33U, 7U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"addw", 4})))) = (nelua_V_4){2, 0x3bU, 0U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"subw", 4})))) = (nelua_V_4){2, 0x3bU, 0U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sllw", 4})))) = (nelua_V_4){2, 0x3bU, 1U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"srlw", 4})))) = (nelua_V_4){2, 0x3bU, 5U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sraw", 4})))) = (nelua_V_4){2, 0x3bU, 5U, 0x20U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sb", 2})))) = (nelua_V_4){3, 0x23U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sh", 2})))) = (nelua_V_4){3, 0x23U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sw", 2})))) = (nelua_V_4){3, 0x23U, 2U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"sd", 2})))) = (nelua_V_4){3, 0x23U, 3U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"beq", 3})))) = (nelua_V_4){4, 0x63U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"bne", 3})))) = (nelua_V_4){4, 0x63U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"blt", 3})))) = (nelua_V_4){4, 0x63U, 4U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"bge", 3})))) = (nelua_V_4){4, 0x63U, 5U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"bltu", 4})))) = (nelua_V_4){4, 0x63U, 6U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"bgeu", 4})))) = (nelua_V_4){4, 0x63U, 7U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"lui", 3})))) = (nelua_V_4){5, 0x37U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"auipc", 5})))) = (nelua_V_4){5, 0x17U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"jal", 3})))) = (nelua_V_4){6, 0x6fU};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"ecall", 5})))) = (nelua_V_4){0, 0x73U, 0U, 0U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"ebreak", 6})))) = (nelua_V_4){0, 0x73U, 0U, 1U};
}
void nelua_require_multiply(nlniltype modname) {
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"mul", 3})))) = (nelua_V_4){2, 0x33U, 0U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"mulh", 4})))) = (nelua_V_4){2, 0x33U, 1U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"mulhsu", 6})))) = (nelua_V_4){2, 0x33U, 2U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"mulhu", 5})))) = (nelua_V_4){2, 0x33U, 3U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"div", 3})))) = (nelua_V_4){2, 0x33U, 4U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"divu", 4})))) = (nelua_V_4){2, 0x33U, 5U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"rem", 3})))) = (nelua_V_4){2, 0x33U, 6U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"remu", 4})))) = (nelua_V_4){2, 0x33U, 7U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"mulw", 4})))) = (nelua_V_4){2, 0x3bU, 0U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"divw", 4})))) = (nelua_V_4){2, 0x3bU, 4U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"divuw", 5})))) = (nelua_V_4){2, 0x3bU, 5U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"remw", 4})))) = (nelua_V_4){2, 0x3bU, 6U, 1U};
  (*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), ((nlstring){(uint8_t*)"remuw", 5})))) = (nelua_V_4){2, 0x3bU, 7U, 1U};
}
uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to usize failed");
  }
  return (uintptr_t)x;
}
nelua_sequence_uint8_ pseudo_concat(nelua_sequence_uint8_ s1, nelua_sequence_uint8_ s2) {
  for(intptr_t i = 1, _end = nelua_sequence_uint8____len((&s2)); i <= _end; i += 1) {
    (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&s1), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&s1)) + 1))))) = (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&s2), nelua_assert_narrow_nlisize_nlusize(i))));
  }
  return s1;
}
nelua_sequence_uint8_ pseudo_anonfunc(nelua_sequence_uint64_ args) {
  if(((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) < 0x800)) {
    return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"addi", 4}), nelua_sequence_uint64____convert_1(({
      nluint64_arr3 _tmp = {0};
      _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
      _tmp.v[1] = 0U;
      _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
      _tmp;
    }))));
  } else {
    if((((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) & 0xfff) == 0)) {
      return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"lui", 3}), nelua_sequence_uint64____convert_2(({
        nluint64_arr2 _tmp = {0};
        _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
        _tmp.v[1] = ((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 12);
        _tmp;
      }))));
    }
    uint64_t upper = ((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 12);
    if((((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) & 0xfff) >= 0x800)) {
      upper = (upper + 1);
    }
    return ({
      nelua_sequence_uint8_ _tmp1 = nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"lui", 3}), nelua_sequence_uint64____convert_2((nluint64_arr2){{(*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))), upper}})));
      nelua_sequence_uint8_ _tmp2 = nelua_sequence_uint8____convert_1(((argHandling_execArgs.bit32 == true) ? instr_getInstr(((nlstring){(uint8_t*)"addi", 4}), nelua_sequence_uint64____convert_1(({
        nluint64_arr3 _tmp = {0};
        _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
        _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
        _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
        _tmp;
      }))) : instr_getInstr(((nlstring){(uint8_t*)"addiw", 5}), nelua_sequence_uint64____convert_1(({
        nluint64_arr3 _tmp = {0};
        _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
        _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
        _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
        _tmp;
      })))));
      pseudo_concat(_tmp1, _tmp2);
    });
  }
}
nelua_sequence_uint8_ pseudo_anonfunc_1(nelua_sequence_uint64_ args) {
  uint64_t val = 0U;
  if(((int64_t)(*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) < 0)) {
    val = ((~(*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)))) >> 12);
  } else {
    val = ((*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U))) >> 12);
  }
  return ({
    nelua_sequence_uint8_ _tmp1 = nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"auipc", 5}), nelua_sequence_uint64____convert_2((nluint64_arr2){{(*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U))), val}})));
    nelua_sequence_uint8_ _tmp2 = nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"addi", 4}), nelua_sequence_uint64____convert_1(({
      nluint64_arr3 _tmp = {0};
      _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
      _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
      _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
      _tmp;
    }))));
    pseudo_concat(_tmp1, _tmp2);
  });
}
nelua_sequence_uint8_ pseudo_anonfunc_2(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"addi", 4}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[2] = 0U;
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_3(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"xori", 4}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[2] = 0xfffU;
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_4(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"sub", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = 0U;
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_5(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"blt", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_6(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bge", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_7(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bltu", 4}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_8(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bgeu", 4}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 3U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_9(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"beq", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = 0U;
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_10(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bne", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = 0U;
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_11(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bge", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[1] = 0U;
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_12(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"bge", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = 0U;
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_13(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"blt", 3}), nelua_sequence_uint64____convert_1(({
    nluint64_arr3 _tmp = {0};
    _tmp.v[0] = 0U;
    _tmp.v[1] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)));
    _tmp.v[2] = (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 2U)));
    _tmp;
  }))));
}
nelua_sequence_uint8_ pseudo_anonfunc_14(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"jal", 3}), nelua_sequence_uint64____convert_2((nluint64_arr2){{0U, (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)))}})));
}
nelua_sequence_uint8_ pseudo_anonfunc_15(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1(instr_getInstr(((nlstring){(uint8_t*)"jal", 3}), nelua_sequence_uint64____convert_2((nluint64_arr2){{1U, (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), 1U)))}})));
}
nelua_sequence_uint8_ pseudo_anonfunc_16(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1((nluint8_arr4){{0x67U, 0x80U, 0U, 0U}});
}
nelua_sequence_uint8_ pseudo_anonfunc_17(nelua_sequence_uint64_ args) {
  return nelua_sequence_uint8____convert_1((nluint8_arr4){{0x13U, 0U, 0U, 0U}});
}
uint8_t nelua_assert_narrow_nluint64_nluint8(uint64_t x) {
  if(NELUA_UNLIKELY(x > 0xffU)) {
    nelua_panic_cstring("narrow casting from uint64 to uint8 failed");
  }
  return (uint8_t)x;
}
nelua_sequence_uint8_ pseudo_anonfunc_18(nelua_sequence_uint64_ args) {
  nelua_sequence_uint8_ ret = (nelua_sequence_uint8_){0};
  {
    nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 _asgnret_1 = nelua_ipairs_3(args);
    function_4JwRVx4oQFacTf3dV __fornext = _asgnret_1.r1;
    nelua_sequence_uint64_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint64 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint64_t v = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8((v & 0xff));
      }
    }
  }
  return ret;
}
nelua_sequence_uint8_ pseudo_anonfunc_19(nelua_sequence_uint64_ args) {
  nelua_sequence_uint8_ ret = (nelua_sequence_uint8_){0};
  {
    nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 _asgnret_1 = nelua_ipairs_3(args);
    function_4JwRVx4oQFacTf3dV __fornext = _asgnret_1.r1;
    nelua_sequence_uint64_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint64 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint64_t v = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8((v & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 8) & 0xff));
      }
    }
  }
  return ret;
}
nelua_sequence_uint8_ pseudo_anonfunc_20(nelua_sequence_uint64_ args) {
  nelua_sequence_uint8_ ret = (nelua_sequence_uint8_){0};
  {
    nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 _asgnret_1 = nelua_ipairs_3(args);
    function_4JwRVx4oQFacTf3dV __fornext = _asgnret_1.r1;
    nelua_sequence_uint64_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint64 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint64_t v = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8((v & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 8) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 16) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 24) & 0xff));
      }
    }
  }
  return ret;
}
nelua_sequence_uint8_ pseudo_anonfunc_21(nelua_sequence_uint64_ args) {
  nelua_sequence_uint8_ ret = (nelua_sequence_uint8_){0};
  {
    nlmulret_function_4JwRVx4oQFacTf3dV_nelua_sequence_uint64__nlint64 _asgnret_1 = nelua_ipairs_3(args);
    function_4JwRVx4oQFacTf3dV __fornext = _asgnret_1.r1;
    nelua_sequence_uint64_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint64 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint64_t v = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8((v & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 8) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 16) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 24) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 32) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 40) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 48) & 0xff));
        (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&ret), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&ret)) + 1))))) = nelua_assert_narrow_nluint64_nluint8(((v >> 56) & 0xff));
      }
    }
  }
  return ret;
}
void nelua_require_pseudo(nlniltype modname) {
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"li", 2})))) = (nelua_V_5){2U, pseudo_anonfunc};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"la", 2})))) = (nelua_V_5){2U, pseudo_anonfunc_1};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"mv", 2})))) = (nelua_V_5){2U, pseudo_anonfunc_2};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"not", 3})))) = (nelua_V_5){2U, pseudo_anonfunc_3};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"neg", 3})))) = (nelua_V_5){2U, pseudo_anonfunc_4};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bgt", 3})))) = (nelua_V_5){3U, pseudo_anonfunc_5};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"ble", 3})))) = (nelua_V_5){3U, pseudo_anonfunc_6};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bgtu", 4})))) = (nelua_V_5){3U, pseudo_anonfunc_7};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bleu", 4})))) = (nelua_V_5){3U, pseudo_anonfunc_8};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"beqz", 4})))) = (nelua_V_5){2U, pseudo_anonfunc_9};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bnez", 4})))) = (nelua_V_5){2U, pseudo_anonfunc_10};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bgez", 4})))) = (nelua_V_5){2U, pseudo_anonfunc_11};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bgez", 4})))) = (nelua_V_5){2U, pseudo_anonfunc_12};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"bgtz", 4})))) = (nelua_V_5){2U, pseudo_anonfunc_13};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"j", 1})))) = (nelua_V_5){1U, pseudo_anonfunc_14};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"call", 4})))) = (nelua_V_5){1U, pseudo_anonfunc_15};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"ret", 3})))) = (nelua_V_5){0U, pseudo_anonfunc_16};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"nop", 3})))) = (nelua_V_5){0U, pseudo_anonfunc_17};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"db", 2})))) = (nelua_V_5){(uint8_t)pseudo_infiniteSize, pseudo_anonfunc_18};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"dh", 2})))) = (nelua_V_5){(uint8_t)pseudo_infiniteSize, pseudo_anonfunc_19};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"dw", 2})))) = (nelua_V_5){(uint8_t)pseudo_infiniteSize, pseudo_anonfunc_20};
  (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"dd", 2})))) = (nelua_V_5){(uint8_t)pseudo_infiniteSize, pseudo_anonfunc_21};
}
uint32_t nelua_assert_narrow_nlint64_nluint32(int64_t x) {
  if(NELUA_UNLIKELY(x < 0 || x > 0xffffffffLL)) {
    nelua_panic_cstring("narrow casting from int64 to uint32 failed");
  }
  return (uint32_t)x;
}
uint32_t elf_addString(nlstring name) {
  int64_t ret = 0;
  name = nelua_nlstring___concat_1(name, ((nlstring){(uint8_t*)"\000", 1}));
  if(nelua_hashmap_string__uint32__has((&elf_names), name)) {
    return (*(uint32_t*)nelua_assert_deref(nelua_hashmap_string__uint32____atindex((&elf_names), name)));
  }
  if((!nelua_nlstring___eq(name, ((nlstring){(uint8_t*)"", 0})))) {
    ret = elf_nameLen;
    (*(uint32_t*)nelua_assert_deref(nelua_hashmap_string__uint32____atindex((&elf_names), name))) = nelua_assert_narrow_nlint64_nluint32(elf_nameLen);
    elf_nameLen = (int64_t)(elf_nameLen + nelua_nlstring___len(name));
  }
  return (uint32_t)ret;
}
uint32_t elf_addSym(nlstring name, uint8_t info, uint64_t value, uint16_t shindex) {
  uint32_t nameN = elf_addString(name);
  intptr_t ret = nelua_sequence_elf64Sym____len((&elf_syms));
  (*(elf_elf64Sym*)nelua_assert_deref(nelua_sequence_elf64Sym____atindex((&elf_syms), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_elf64Sym____len((&elf_syms)) + 1))))) = (elf_elf64Sym){nameN, info, 0U, shindex, value, 0U};
  return (uint32_t)ret;
}
void elf_addShdr(nlstring name, uint64_t sType, uint32_t flag, uint64_t size, uint64_t offset) {
  if((sType == 0)) {
    (*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_elf64Shdr____len((&elf_shdrs)) + 1))))) = (elf_elf64Shdr){0U};
    return;
  }
  int64_t align = 1;
  if(nelua_nlstring___eq(name, ((nlstring){(uint8_t*)".text", 5}))) {
    align = 4;
  }
  int64_t link = 0;
  int64_t eSize = 0;
  int64_t info = 0;
  uint32_t nameN = elf_addString(name);
  elf_elf64Shdr shdr = (elf_elf64Shdr){nameN, (uint32_t)sType, (uint64_t)flag, (elf_addressOffset + offset), offset, size, (uint32_t)link, (uint32_t)info, (uint64_t)align, (uint64_t)eSize};
  (*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_elf64Shdr____len((&elf_shdrs)) + 1))))) = shdr;
}
size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to csize failed");
  }
  return (size_t)x;
}
void elf_writeToFile(nlstring filename, nelua_sequence_uint8_ program_1, uint64_t start) {
  bool strip = argHandling_execArgs.strip;
  elf_addShdr(((nlstring){(uint8_t*)".text", 5}), 1U, 7U, nelua_assert_narrow_nlint64_nluint64(common_getProgramSize()), nelua_assert_narrow_nlint64_nluint64((64 + (64 * ((strip == true) ? 1 : 2)))));
  if((!strip)) {
    elf_addShdr(((nlstring){(uint8_t*)".shstrtab", 9}), 3U, 0U, 0U, nelua_assert_narrow_nlint64_nluint64(((192 + common_getProgramSize()) + 56)));
    (*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize(nelua_sequence_elf64Shdr____len((&elf_shdrs)))))).sh_addr = ((*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize(nelua_sequence_elf64Shdr____len((&elf_shdrs)))))).sh_addr - elf_addressOffset);
    (*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize(nelua_sequence_elf64Shdr____len((&elf_shdrs)))))).sh_size = nelua_assert_narrow_nlint64_nluint64(elf_nameLen);
  }
  elf_elf64Phdr ph = (elf_elf64Phdr){1U, 7U, 0U, elf_addressOffset, elf_addressOffset, (uint64_t)(common_getProgramSize() + elf_paddingSize), (uint64_t)(common_getProgramSize() + elf_paddingSize), 0x1000U};
  elf_elf64Ehdr header = (elf_elf64Ehdr){{0x7fU, 0x45U, 0x4cU, 0x46U, 2U, 1U, 1U, 0U}, 2U, 243U, 1U, (uint64_t)(int64_t)((int64_t)((64 + elf_addressOffset) + (nelua_sequence_elf64Shdr____len((&elf_shdrs)) * 64)) + start), (uint64_t)((64 + common_getProgramSize()) + (nelua_sequence_elf64Shdr____len((&elf_shdrs)) * 64)), 64U, 4U, 64U, 56U, 1U, 64U, (uint16_t)nelua_sequence_elf64Shdr____len((&elf_shdrs)), (uint16_t)(nelua_sequence_elf64Shdr____len((&elf_shdrs)) - 1)};
  FILE_ptr file = fopen(nelua_assert_string2cstring(filename), (char*)"w");
  if((file == ((FILE_ptr)0))) {
    nelua_os_exit_1(1);
  }
  fwrite((void*)(&header), 64U, 1U, (void*)file);
  for(intptr_t i = 1, _end = nelua_sequence_elf64Shdr____len((&elf_shdrs)); i <= _end; i += 1) {
    fwrite((void*)(&(*(elf_elf64Shdr*)nelua_assert_deref(nelua_sequence_elf64Shdr____atindex((&elf_shdrs), nelua_assert_narrow_nlisize_nlusize(i))))), 64U, 1U, (void*)file);
  }
  fwrite((void*)(&(*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&program_1), 1U)))), 1U, nelua_assert_narrow_nlisize_nlcsize(nelua_sequence_uint8____len((&program_1))), (void*)file);
  fwrite((void*)(&ph), 56U, 1U, (void*)file);
  if((!strip)) {
    {
      nlmulret_function_Be9dheYyhVZZMPGH_nelua_hashmap_iteratorT_6_nlstring _asgnret_1 = nelua_pairs_2((&elf_names));
      function_Be9dheYyhVZZMPGH __fornext = _asgnret_1.r1;
      nelua_hashmap_iteratorT_6 __forstate = _asgnret_1.r2;
      nlstring __fornextit = _asgnret_1.r3;
      while(true) {
        nlmulret_nlboolean_nlstring_nluint32 _asgnret_2 = __fornext((&__forstate), __fornextit);
        bool __forcont = _asgnret_2.r1;
        nlstring k = _asgnret_2.r2;
        if((!__forcont)) {
          break;
        }
        __fornextit = k;
        {
          fwrite((void*)(&(*(uint8_t*)nelua_assert_deref(nelua_nlstring___atindex(k, 1U)))), nelua_assert_narrow_nlisize_nlcsize(nelua_nlstring___len(k)), 1U, (void*)file);
        }
      }
    }
  }
  fclose(file);
}
void nelua_require_elf(nlniltype modname) {
  elf_addString(((nlstring){(uint8_t*)"\000", 1}));
  elf_addSym(((nlstring){(uint8_t*)"", 0}), 0U, 0U, 0U);
}
void main_checkSyntax(syntax_syntax syn) {
  if((((main_expects.v[0] == 255) || (syn.type == 2)) || (syn.type == 255))) {
    return;
  }
  for(intptr_t i = 0; i < 5; i += 1) {
    if((main_expects.v[nelua_assert_bounds_nlisize(i, 5)] == 255)) {
      break;
    }
    if((syn.type == main_expects.v[nelua_assert_bounds_nlisize(i, 5)])) {
      return;
    }
    if(((syn.type == 0) && (main_expects.v[nelua_assert_bounds_nlisize(i, 5)] == 1))) {
      return;
    }
  }
  if((syn.type == 1)) {
    common_rasmError_1(((nlstring){(uint8_t*)"Unexpected Newline", 18}), NELUA_NIL);
  } else {
    common_rasmError_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"\"", 1}), nelua_nlstring___concat_1(syn.str, nelua_nlstring___concat_1(((nlstring){(uint8_t*)"\"", 1}), ((nlstring){(uint8_t*)" Unexpected Syntax", 18})))), NELUA_NIL);
  }
}
int64_t nelua_assert_narrow_nluint64_nlint64(uint64_t x) {
  if(NELUA_UNLIKELY(x > 0x7fffffffffffffffULL)) {
    nelua_panic_cstring("narrow casting from uint64 to int64 failed");
  }
  return (int64_t)x;
}
void main_addLabel(nlstring name, uint64_t value, bool isAddr) {
  if(nelua_hashmap_string__V__has((&label_labels), name)) {
    common_rasmError_1(((nlstring){(uint8_t*)"Label already exist", 19}), NELUA_NIL);
  }
  if(isAddr) {
    if((!nelua_nlstring___eq(main_preLabel, ((nlstring){(uint8_t*)"", 0})))) {
      (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), main_preLabel))).length = nelua_assert_narrow_nluint64_nlint64((value - main_preAddressLabel));
    }
    (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), name))) = (nelua_V_3){value, 0};
    main_preAddressLabel = main_addressLabel;
    main_preLabel = name;
  } else {
    (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), name))) = (nelua_V_3){value, -1};
  }
}
nelua_sequence_string_ main_getCallArgs(void) {
  syntax_syntax syn = (syntax_syntax){0};
  main_expects = (nluint8_arr5){{6U, 5U, 7U, 255U}};
  nlstring stringArg = (nlstring){0};
  nelua_sequence_string_ args = (nelua_sequence_string_){0};
  {
    bool _repeat_stop;
    do {
      syn = syntax_Parse(main_file);
      main_checkSyntax(syn);
      if(((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)",", 1})))) {
        main_expects.v[0] = 6U;
        main_expects.v[1] = 5U;
        main_expects.v[2] = 3U;
        main_expects.v[3] = 255U;
      } else if((((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)"%", 1}))) && nelua_nlstring___eq(stringArg, ((nlstring){(uint8_t*)"", 0})))) {
        stringArg = nelua_nlstring___concat_1(stringArg, syn.str);
        main_expects.v[0] = 6U;
        main_expects.v[1] = 255U;
      } else if((syn.type == 3)) {
        common_rasmError_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Expected ',' Not '", 18}), nelua_nlstring___concat_1(syn.str, ((nlstring){(uint8_t*)"''", 2}))), NELUA_NIL);
      } else if(((syn.type == 6) || (syn.type == 5))) {
        main_expects.v[0] = 3U;
        main_expects.v[1] = 7U;
        main_expects.v[2] = 255U;
        (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&args), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_string____len((&args)) + 1))))) = nelua_nlstring___concat_1(stringArg, syn.str);
        stringArg = ((nlstring){(uint8_t*)"", 0});
      }
      _repeat_stop = ((syn.type == 7) || (syn.type == 255));
    } while(!_repeat_stop);
  }
  return args;
}
bool nelua_lt_nlisize_nluint8(intptr_t a, uint8_t b) {
  return a < 0 || (uint64_t)a < b;
}
bool nelua_lt_nluint8_nlisize(uint8_t a, intptr_t b) {
  return b > 0 && a < (uint64_t)b;
}
bool main_parseVar(syntax_syntax syn) {
  if(nelua_hashmap_string__V__1_has((&instr_instruction), syn.str)) {
    main_addressLabel = (main_addressLabel + 4);
    main_expects = (nluint8_arr5){{1U, 6U, 5U, 255U}};
    uint8_t size = 0U;
    switch((*(nelua_V_4*)nelua_assert_deref(nelua_hashmap_string__V__1___atindex((&instr_instruction), syn.str))).type) {
      case 0: {
        break;
      }
      case 5: {
        NELUA_FALLTHROUGH(); /* fallthrough */
      }
      case 6: {
        size = 2U;
        break;
      }
      case 3: {
        NELUA_FALLTHROUGH(); /* fallthrough */
      }
      case 4: {
        NELUA_FALLTHROUGH(); /* fallthrough */
      }
      case 2: {
        NELUA_FALLTHROUGH(); /* fallthrough */
      }
      case 1: {
        size = 3U;
        break;
      }
    }
    uint8_t argc = 0U;
    {
      bool _repeat_stop;
      do {
        syn = syntax_Parse(main_file);
        main_checkSyntax(syn);
        if(((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)",", 1})))) {
          main_expects.v[0] = 6U;
          main_expects.v[1] = 5U;
          main_expects.v[2] = 3U;
          main_expects.v[3] = 255U;
        } else if(((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)"%", 1})))) {
          main_expects.v[0] = 6U;
          main_expects.v[1] = 255U;
        } else if((syn.type == 3)) {
          common_rasmError_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Expected ',' Not '", 18}), nelua_nlstring___concat_1(syn.str, ((nlstring){(uint8_t*)"''", 2}))), NELUA_NIL);
        } else if(((syn.type == 6) || (syn.type == 5))) {
          main_expects.v[0] = 3U;
          main_expects.v[1] = 1U;
          main_expects.v[2] = 255U;
          argc = (argc + 1);
        }
        _repeat_stop = ((syn.type == 1) || (syn.type == 255));
      } while(!_repeat_stop);
    }
    if((size > argc)) {
      common_rasmError_1(((nlstring){(uint8_t*)"Too Few Operand", 15}), NELUA_NIL);
    } else if((size < argc)) {
      common_rasmError_1(((nlstring){(uint8_t*)"Too Many Operand", 16}), NELUA_NIL);
    }
    main_expects = (nluint8_arr5){{1U, 6U, 255U}};
    return (syn.type == 255);
  } else if(nelua_hashmap_string__V__2_has((&pseudo_pseudoInstr), syn.str)) {
    nlstring mnemonic = syn.str;
    nelua_sequence_uint64_ args = (nelua_sequence_uint64_){0};
    syn = syntax_Parse(main_file);
    main_expects.v[0] = 6U;
    main_expects.v[1] = 5U;
    main_expects.v[2] = 255U;
    nlstring stringArg = (nlstring){0};
    while(((syn.type != 1) && (syn.type != 255))) {
      main_checkSyntax(syn);
      if(((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)",", 1})))) {
        main_expects.v[0] = 6U;
        main_expects.v[1] = 5U;
        main_expects.v[2] = 3U;
        main_expects.v[3] = 255U;
      } else if((((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)"%", 1}))) && nelua_nlstring___eq(stringArg, ((nlstring){(uint8_t*)"", 0})))) {
        stringArg = nelua_nlstring___concat_1(stringArg, syn.str);
        main_expects.v[0] = 6U;
        main_expects.v[1] = 255U;
      } else if((syn.type == 3)) {
        common_rasmError_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Expected ',' Not '", 18}), nelua_nlstring___concat_1(syn.str, ((nlstring){(uint8_t*)"''", 2}))), NELUA_NIL);
      } else if(((syn.type == 6) || (syn.type == 5))) {
        main_expects.v[0] = 3U;
        main_expects.v[1] = 1U;
        main_expects.v[2] = 255U;
        (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint64____len((&args)) + 1))))) = instr_getArg(nelua_nlstring___concat_1(stringArg, syn.str));
        stringArg = ((nlstring){(uint8_t*)"", 0});
      }
      syn = syntax_Parse(main_file);
    }
    main_expects.v[0] = 1U;
    main_expects.v[1] = 6U;
    main_expects.v[2] = 255U;
    if(((*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), mnemonic))).argc != 0xff)) {
      if(nelua_lt_nlisize_nluint8(nelua_sequence_uint64____len((&args)), (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), mnemonic))).argc)) {
        common_rasmError_1(((nlstring){(uint8_t*)"Too Few Operand", 15}), NELUA_NIL);
      } else if(nelua_lt_nluint8_nlisize((*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), mnemonic))).argc, nelua_sequence_uint64____len((&args)))) {
        common_rasmError_1(((nlstring){(uint8_t*)"Too Many Operand", 16}), NELUA_NIL);
      }
    }
    intptr_t length = nelua_sequence_uint8____len(NELUA_LITERAL_REF(nelua_sequence_uint8_, ((*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), mnemonic))).assemble(args))));
    main_addressLabel = nelua_assert_narrow_nlint64_nluint64((int64_t)(main_addressLabel + length));
    return (syn.type == 255);
  }
  return false;
}
intptr_t nelua_assert_imod_nlisize(intptr_t a, intptr_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0;
  if(NELUA_UNLIKELY(b == 0)) nelua_panic_cstring("division by zero");
  intptr_t r = a % b;
  return (r != 0 && (a ^ b) < 0) ? r + b : r;
}
int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
void main_addInstrToProgram(nluint8_arr4 instr) {
  for(int64_t i = 0; i <= 3; i += 1) {
    (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = instr.v[nelua_assert_bounds_nlint64(i, 4)];
  }
}
int nelua_main(int argc, char** argv) {
  nelua_argc = argc;
  nelua_argv = argv;
  nelua_require_arg(NELUA_NIL);
  main_usageStr = nelua_nlstring___concat_1(((nlstring){(uint8_t*)"Usage: ", 7}), nelua_nlstring___concat_1((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 0U))), ((nlstring){(uint8_t*)"[d][s][o a.out] filein.asm\n'-' are optional.", 44})));
  if((nelua_sequence_string__1___len((&nelua_arg)) == 0)) {
    nelua_print_1(main_usageStr);
    return 2;
  }
  nelua_require_io(NELUA_NIL);
  nelua_require_argHandling(NELUA_NIL);
  nelua_require_label(NELUA_NIL);
  nelua_require_base(NELUA_NIL);
  nelua_require_multiply(NELUA_NIL);
  nelua_require_pseudo(NELUA_NIL);
  nelua_require_elf(NELUA_NIL);
  main_file = nelua_io_open_1(common_filein, NELUA_NIL).r1;
  if((!nelua_filestream_isopen((&main_file)))) {
    nelua_print_1(((nlstring){(uint8_t*)"Error: unable to open filein", 28}));
    nelua_os_exit_1(1);
  }
  if(argHandling_execArgs.dump) {
    main_cfile = fopen((char*)"dump.bin", (char*)"wb+");
  }
  main_expects = (nluint8_arr5){{1U, 6U, 255U}};
  while(true) {
    syntax_syntax syn = syntax_Parse(main_file);
    if((syn.type == 255)) {
      break;
    }
    main_checkSyntax(syn);
    switch(syn.type) {
      case 0: {
        NELUA_FALLTHROUGH(); /* fallthrough */
      }
      case 2: {
        continue;
      }
      case 1: {
        main_expects = (nluint8_arr5){{1U, 6U, 255U}};
        break;
      }
      case 3: {
        main_expects.v[0] = 3U;
        main_expects.v[1] = 5U;
        main_expects.v[2] = 4U;
        main_expects.v[3] = 255U;
        if(nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)"=", 1}))) {
          main_expects.v[1] = 5U;
          main_expects.v[2] = 4U;
          main_expects.v[3] = 255U;
          {
            bool _repeat_stop;
            do {
              syn = syntax_Parse(main_file);
              main_checkSyntax(syn);
              _repeat_stop = (syn.type != 2);
            } while(!_repeat_stop);
          }
          if((syn.type == 5)) {
            main_addLabel(main_lastVar, (uint64_t)nelua_tointeger_1(syn.str, NELUA_NIL), false);
          } else {
            nlstring str = common_parseString(syn.str);
            for(intptr_t i = 1, _end = nelua_nlstring___len(str); i <= _end; i += 1) {
              (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = (*(uint8_t*)nelua_assert_deref(nelua_nlstring___atindex(str, nelua_assert_narrow_nlisize_nlusize(i))));
            }
            common_stringLen = nelua_assert_narrow_nlint64_nluint64((int64_t)(common_stringLen + nelua_nlstring___len(str)));
            main_addLabel(main_lastVar, main_addressLabel, true);
            main_addressLabel = nelua_assert_narrow_nlint64_nluint64((int64_t)(main_addressLabel + nelua_nlstring___len(str)));
            if((nelua_assert_imod_nlisize(nelua_nlstring___len(str), 2) == 1)) {
              (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = 0U;
              main_addressLabel = (main_addressLabel + 1);
            }
          }
          main_expects.v[0] = 1U;
          main_expects.v[1] = 255U;
        } else if(nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)":", 1}))) {
          main_addLabel(main_lastVar, main_addressLabel, true);
          main_expects.v[0] = 1U;
          main_expects.v[1] = 255U;
        } else {
        }
        break;
      }
      case 7: {
        main_addressLabel = nelua_assert_narrow_nlint64_nluint64(((int64_t)(main_addressLabel + (nelua_sequence_string____len(NELUA_LITERAL_REF(nelua_sequence_string_, (main_getCallArgs()))) * 4)) + 4));
        main_expects = (nluint8_arr5){{1U, 255U}};
        break;
      }
      case 4: {
        break;
      }
      case 5: {
        main_expects.v[0] = 3U;
        main_expects.v[1] = 5U;
        main_expects.v[2] = 1U;
        main_expects.v[3] = 255U;
        break;
      }
      case 6: {
        main_expects = (nluint8_arr5){{3U, 7U, 6U, 255U}};
        if(main_parseVar(syn)) {
          goto _breaklabel_1;
        }
        main_lastVar = syn.str;
        break;
      }
    }
  }
  _breaklabel_1:;
  (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), main_preLabel))).length = nelua_assert_narrow_nluint64_nlint64((main_addressLabel - main_preAddressLabel));
  if((!nelua_hashmap_string__V__has((&label_labels), ((nlstring){(uint8_t*)"_start", 6})))) {
    nelua_print_1(nelua_nlstring___concat_1(common_filein, nelua_nlstring___concat_1(((nlstring){(uint8_t*)": Error: ", 9}), ((nlstring){(uint8_t*)"failed to find '_start' label", 29}))));
    nelua_os_exit_1(1);
  }
  nelua_filestream_seek_1((&main_file), ((nlstring){(uint8_t*)"set", 3}), NELUA_NIL);
  common_curLine = 1;
  {
    bool _repeat_stop;
    do {
      syntax_syntax syn = syntax_Parse(main_file);
      nelua_sequence_uint64_ args = (nelua_sequence_uint64_){0};
      if((nelua_hashmap_string__V__1_has((&instr_instruction), syn.str) || nelua_hashmap_string__V__2_has((&pseudo_pseudoInstr), syn.str))) {
        nlstring mnemonic = syn.str;
        int64_t i = 1;
        {
          bool _repeat_stop;
          do {
            syn = syntax_Parse(main_file);
            if(((syn.type == 3) && nelua_nlstring___eq(syn.str, ((nlstring){(uint8_t*)"%", 1})))) {
              syn = syntax_Parse(main_file);
              (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), nelua_assert_narrow_nlint64_nlusize(i)))) = instr_getArg(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"%", 1}), syn.str));
              i = (i + 1);
              syn = syntax_Parse(main_file);
            }
            if(((syn.type == 5) || (syn.type == 6))) {
              if(((syn.type == 6) && (!nelua_hashmap_string__V__has((&label_labels), syn.str)))) {
                common_rasmError_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"No label called ", 16}), syn.str), NELUA_NIL);
              }
              (*(uint64_t*)nelua_assert_deref(nelua_sequence_uint64____atindex((&args), nelua_assert_narrow_nlint64_nlusize(i)))) = instr_getArg(syn.str);
              i = (i + 1);
            }
            _repeat_stop = ((syn.type == 1) || (syn.type == 255));
          } while(!_repeat_stop);
        }
        if(nelua_hashmap_string__V__1_has((&instr_instruction), mnemonic)) {
          main_addInstrToProgram(instr_getInstr(mnemonic, args));
        } else {
          nelua_sequence_uint8_ bytes = (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), mnemonic))).assemble(args);
          for(intptr_t i_3 = 1, _end = nelua_sequence_uint8____len((&bytes)); i_3 <= _end; i_3 += 1) {
            (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&bytes), nelua_assert_narrow_nlisize_nlusize(i_3))));
          }
        }
      }
      if((nelua_hashmap_string__V__has((&label_labels), syn.str) && ((*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), syn.str))).length != -1))) {
        nlstring label = syn.str;
        {
          bool _repeat_stop;
          do {
            syn = syntax_Parse(main_file);
            _repeat_stop = (syn.type != 2);
          } while(!_repeat_stop);
        }
        if((syn.type == 7)) {
          nelua_sequence_string_ strs = main_getCallArgs();
          for(intptr_t i = 1, _end = nelua_sequence_string____len((&strs)); i <= _end; i += 1) {
            if(((nelua_nlstring_match_1((*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i)))), ((nlstring){(uint8_t*)"^-?%d*$", 7}), NELUA_NIL).r1 || nelua_nlstring_match_1((*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i)))), ((nlstring){(uint8_t*)"^%%", 3}), NELUA_NIL).r1) || (nelua_hashmap_string__V__has((&label_labels), (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i))))) && ((*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), (*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i))))))).length == -1)))) {
              nelua_sequence_uint8_ bytes = (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"li", 2})))).assemble(nelua_sequence_uint64____convert_2((nluint64_arr2){{(uint64_t)(9 + i), instr_getArg((*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i)))))}}));
              for(intptr_t i_4 = 1, _end = nelua_sequence_uint8____len((&bytes)); i_4 <= _end; i_4 += 1) {
                (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&bytes), nelua_assert_narrow_nlisize_nlusize(i_4))));
              }
            } else {
              nelua_sequence_uint8_ bytes = (*(nelua_V_5*)nelua_assert_deref(nelua_hashmap_string__V__2___atindex((&pseudo_pseudoInstr), ((nlstring){(uint8_t*)"la", 2})))).assemble(nelua_sequence_uint64____convert_2((nluint64_arr2){{(uint64_t)(9 + i), instr_getArg((*(nlstring*)nelua_assert_deref(nelua_sequence_string____atindex((&strs), nelua_assert_narrow_nlisize_nlusize(i)))))}}));
              for(intptr_t i_5 = 1, _end = nelua_sequence_uint8____len((&bytes)); i_5 <= _end; i_5 += 1) {
                (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&common_program), nelua_assert_narrow_nlisize_nlusize((nelua_sequence_uint8____len((&common_program)) + 1))))) = (*(uint8_t*)nelua_assert_deref(nelua_sequence_uint8____atindex((&bytes), nelua_assert_narrow_nlisize_nlusize(i_5))));
              }
            }
          }
          args = nelua_sequence_uint64____convert_2((nluint64_arr2){{1U, instr_getArg(label)}});
          main_addInstrToProgram(instr_getInstr(((nlstring){(uint8_t*)"jal", 3}), args));
        }
      }
      _repeat_stop = (syn.type == 255);
    } while(!_repeat_stop);
  }
  nelua_filestream_close((&main_file));
  if(argHandling_execArgs.dump) {
    {
      nlmulret_function_2jz3PiVxWVVz2SR8n_nelua_sequence_uint8__nlint64 _asgnret_1 = nelua_ipairs_4(common_program);
      function_2jz3PiVxWVVz2SR8n __fornext = _asgnret_1.r1;
      nelua_sequence_uint8_ __forstate = _asgnret_1.r2;
      int64_t __fornextit = _asgnret_1.r3;
      while(true) {
        nlmulret_nlboolean_nlint64_nluint8 _asgnret_2 = __fornext(__forstate, __fornextit);
        bool __forcont = _asgnret_2.r1;
        int64_t _ = _asgnret_2.r2;
        uint8_t v = _asgnret_2.r3;
        if((!__forcont)) {
          break;
        }
        __fornextit = _;
        {
          fwrite((void*)(&v), 1U, 1U, (void*)main_cfile);
        }
      }
    }
    fclose(main_cfile);
  }
  elf_writeToFile(argHandling_fileout, common_program, (*(nelua_V_3*)nelua_assert_deref(nelua_hashmap_string__V____atindex((&label_labels), ((nlstring){(uint8_t*)"_start", 6})))).value);
  nelua_io_popen_1(nelua_nlstring___concat_1(((nlstring){(uint8_t*)"chmod +x ", 9}), nelua_nlstring___concat_1(argHandling_fileout, ((nlstring){(uint8_t*)" 2> /dev/null", 13}))), NELUA_NIL);
  return 0;
}
